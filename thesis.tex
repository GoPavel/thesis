\documentclass[times
              ,specification
              ,annotation
              ]{itmo-student-thesis}

\usepackage{amssymb}
\usepackage{mathtools}
\usepackage{lstcoq}
\usepackage{graphicx}
% NOTE bug in cls: link to fig,tab,lst lead to first page
\usepackage[unicode=true,implicit=false]{hyperref}
\usepackage{tikz}
\usepackage{subfigure}
\lstset
{
  language=Coq,
  numbers=left,
  mathescape=true,
  xleftmargin=1.5em
}

\input{defs.tex}

\addbibresource{thesis.bib}

% \let\emptyset\varnothing
\newcommand{\redmath}[1]{\mathbin{\textcolor{red}{#1}}}
\newcolumntype{Y}{>{\centering\arraybackslash}X}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}

\begin{document}
\studygroup{M3439}
\title{Применение теории Алгебр Клини и ее расширений для автоматизации доказательств в системе Coq  }
\author{Головин Павел Андреевич}{Головин П. А.}
\supervisor{Чивилихин Даниил Сергеевич}{Чивилихин Д. С.}{к.т.н.}{научный сотрудник Университета ИТМО}
\publishyear{2020}
%% Дата выдачи задания. Можно не указывать, тогда надо будет заполнить от руки.
\startdate{01}{сентября}{2019}
%% Срок сдачи студентом работы. Можно не указывать, тогда надо будет заполнить от руки.
\finishdate{28}{мая}{2020}
%% Дата защиты. Можно не указывать, тогда надо будет заполнить от руки.
\defencedate{1}{июня}{2020}

\addconsultant{Моисеенко Е. А.}{без степени, без звания}

\secretary{Павлова О.Н.}

%% Задание
%%% Техническое задание и исходные данные к работе
\technicalspec{
Требуется исследовать применимость теории алгебр Клини и ее расширений для автоматизации доказательств в
системе Coq. В частности для доказательств, связанных с моделями памяти.
Требуется изучить существующие реализации алгебр Клини в Coq и проанализировать их применение на
реальных доказательствах, связанных с моделями памяти.
}

%%% Содержание выпускной квалификационной работы (перечень подлежащих разработке вопросов)
\plannedcontents{
  \begin{enumerate}
    \item Изучение алгебр Клини на предмет использования в доказательствах, связанных с моделями памяти.
    \item Анализ существующих реализаций алгебр Клини в Coq.
    \item Применение алгебры Клини к реальным доказательствам, связанным с моделями памяти.
    \item Оценка результатов.
  \end{enumerate}
}

%%% Исходные материалы и пособия
\plannedsources{\begin{enumerate}
  \item Brunet P. Algebras of Relations : from algorithms to formal proofs :
    Theses : 2016LYSE1198 / Brunet Paul. — Université de Lyon, 10/2016. 
  \item Pous D. Kleene Algebra with Tests and Coq Tools for while Programs // Interactive Theorem
    Proving  / ed. by S. Blazy, C. Paulin-Mohring, D. Pichardie.
    — Berlin, Heidelberg : Springer Berlin Heidelberg, 2013. — P. 180–196. —
    ISBN 978-3-642-39634-2.
  \item Repairing Sequential Consistency in C/C++11 / O. Lahav [et al.] // Proceedings of the 38th ACM
    SIGPLAN Conference on Programming Language Design and Implementation. — Barcelona, Spain :
    Association for Computing Machinery, 2017. — P. 618–632. — (PLDI 2017). — ISBN 9781450349888. —
    DOI: 10.1145/3062341.3062352.

\end{enumerate}}

%%% Цель исследования
\researchaim{Исследовать перспективность использования теории алгебры Клини и ее
  расширений для упрощения формальных доказательств в системе Coq, связанных с моделями памяти.}

%%% Задачи, решаемые в ВКР
\researchtargets{\begin{enumerate}
    \item Применение одной из существующих реализаций алгебры Клини к реальным доказательствам,
      связанным с моделями памяти.
    \item Оценить количество доказательств, которые удалось автоматизировать.
\end{enumerate}}

%%% Использование современных пакетов компьютерных программ и технологий
\addadvancedsoftware{Система интерактивных доказательств Coq}
{\ref{section:coq_impls}, \ref{chapter:2},\ref{chapter:3}}
\addadvancedsoftware{Пакет с формализацией алгебр Клини relation-algebra}
{\ref{chapter:2}, \ref{chapter:3}}
\addadvancedsoftware{Коллекция доказательств свойств бинарных отношений и списков hahn}
{\ref{chapter:2}, \ref{chapter:3}}
\addadvancedsoftware{\LaTeX}
{\ref{chapter:1}, \ref{chapter:2}, \ref{chapter:3}}
%%% Краткая характеристика полученных результатов
\researchsummary{
  Были исследованы различные расширения теории алгебр Клини, а также их реализации в Coq. Самая полная
  из существующих на сегодняшний день была испытана на реальных доказательствах, связанных с моделями
  памяти. Эта реализация формализует алгебры Клини с тестами, благодаря которым удалось автоматизировать
  существенное количество доказательств, что говорит о перспективность данного метода.
}

%%% Гранты, полученные при выполнении работы
\researchfunding{Нет}

%%% Наличие публикаций и выступлений на конференциях по теме выпускной работы
\researchpublications{Нет}

%% Эта команда генерирует титульный лист и аннотацию.
\maketitle{Бакалавр}

%% Оглавление
\tableofcontents

%% Макрос для введения. Совместим со старым стилевиком.
\startprefacepage
\startrelatedwork

%:Needs:
%      Актуальность работы
%      Цели и задачи работы
%      Новизна работы
%      Практическое значение работы
%      Ссылки на доклады и публикации
%      Краткое описание структуры работы по главам

  Сегодня компьютерные технологии все чаще используются в медицине, энергетике, финансах и
  машиностроении, где цена ошибки в коде очень высока и даже может стоить человеческих жизней.
  Это заставляет обратить пристальное внимание на корректность программ.

  За последние годы был достигнут большой прогресс в области построения систем интерактивного
  доказательства теорем, которые позволяют формально верифицировать программы.
  Пользователь такой системы должен сначала формализовать программу и ее спецификацию, а потом с помощью
  специального языка написать доказательство, которое система проверит на корректность.
  Примерами таких систем являются Coq \cite{intro_to_coq}, Agda \cite{agda}, Isabelle/HOL \cite{hol},
  Idris \cite{idris}.

  Coq среди этих инструментов имеет наиболее развитую экосистему и большое сообщество.
  Он часто используется для создания верифицированных систем, связанных с компиляцией языков
  программирования \cite{comp-cert, vellvm} и, в частности, для формализации слабых моделей
  памяти \cite{rc11, imm}.

  Модель памяти языка программирования призвана специфицировать поведения параллельных программ в
  присутствии гонок по данным.
  Простые модели памяти позволяют себе просто запрещать гонки или гарантируют последовательную
  согласованность всех операций (событий) в программе.

  Но такой подход сильно ограничивает параллелизм и мешает компилятору оптимизировать код, от чего сильно
  страдает производительность программ.
  Поэтому на сегодняшний день все языки используют более слабые ограничения (слабые модели памяти).

  Такие модели часто используют бинарные отношения на элементарных событиях чтения и записи, например,
  отношение синхронизации на атомарных переменных <<synchronized with>> \cite{rc11}, чтобы выделить только
  конфликтующие операции и наложить ограничения на возможные исполнения программы.

  Проблема заключается в том, что создание формальной слабой модели памяти, которая корректно применима
  при компиляции программы под разные архитектуры - очень сложная задача, требующая объемных
  доказательств с аккуратным рассмотрением большого количества случаев.
  Поэтому при разработке современных моделей памяти стараются использовать системы интерактивного
  доказательства теорем \cite{rc11}, чтобы упростить написание и проверку доказательств с помощью
  компьютера.

  Так как, работая со слабыми моделям памяти, мы часто имеем дело с бинарными отношениями, то можно
  попробовать обобщить и вынести (автоматизировать) доказательства утверждений, связанных с их свойствами.
  Это должно облегчить разработку и исследование слабых моделей памяти в системе Coq.

  Алгебра Клини - это алгебраическое обобщение бинарных отношений, регулярных выражений и некоторых
  других конструкций со схожей сигнатурой.
  Эта теория хорошо изучена и имеет ряд интересных расширений.

  Цель данной работы заключается в исследовании перспективности использования теории алгебр Клини и ее
  расширений для упрощения формальных доказательств в системе Coq, связанных с моделями памяти.

  %% Краткое описание глав

  В первой главе рассматривается алгебра Клини и ее расширения, анализируется их применимость к
  доказательствам в моделях памяти. Также рассматриваются существующие реализации этой теории в Coq.
  Формулируются цели и задачи работы.

  Во второй главе описывается предлагаемый способ применения одной из реализаций теории алгебр Клини
  для упрощения связанных с моделями памяти доказательства. Проводится сравнение с другими способами автоматизации. 

  В третьей главе анализируется эффективность использования нового метода на практике, рассматриваются
  возникшие проблемы.

\chapter{Обзор теории алгебр Клини и ее реализаций в Coq}\label{chapter:1}
  %% Постановка цели

  Как было сказано выше, модели памяти могут строиться с помощью бинарных отношений над множеством
  элементарных событий. Такие модели называются аксиоматические \cite{axiomatic_memory_model_for_power_mp}.

  В качестве примера рассмотрим Рисунок \ref{fig:pic1} с параллельной программой,
  которая выполняется в двух потоках. Код этой программы содержит гонку по данным: переменные
  \textit{x} и \textit{y} одновременно читаются и пишутся из разных потоков,
  поэтому могут иметь место несколько вариантов исполнения.

  \begin{figure}[!h]
    \caption{Пример параллельной программы, содержащей гонку}
    \label{fig:pic1}
    \centering
    \begin{equation}
      \inarrII{
        \readInst{}{a}{x}  \\
        \writeInst{}{y}{1} \\
      }{
        \readInst{}{b}{y}  \\
        \writeInst{}{x}{1} \\
      }
    \end{equation}
  \end{figure}

  % На рисунке \ref{fig:pic1} мы видим конкретное исполнение программы, то есть мы знаем, например, какие
  % значения были прочитаны из памяти в каждой строчке.

  Для каждого возможного исполнения
  строятся аксиоматически заданные базовые отношения,
  как например на Рисунке \ref{fig:pic2}, это
  отношение порядка команд в коде программы (\textit{po}) и отношения <<прочитано из>> (\textit{rf}),
  которое показывает, где было прочитано записанное значение.

  \begin{figure}[!h]
    \caption{Различные исполнения кода на Рисунке \ref{fig:pic1}}
    \label{fig:pic2}
    \begin{minipage}[c][1\width]{0.3\textwidth}
      \begin{tikzpicture}[yscale=1,xscale=1.3]

        \node (init) at (1,  1.5) {$\Init$};

        \node (i11) at ( 0,  0) {$\rlab{}{x}{0}$};
        \node (i12) at ( 0, -2) {$\wlab{}{y}{1}$};

        \node (i21) at ( 2,  0) {$\rlab{}{y}{0}$};
        \node (i22) at ( 2, -2) {$\wlab{}{x}{1}$};

        \draw[po] (i11) edge node[left] {\small$\lPO$} (i12);
        \draw[po] (i21) edge node[right] {\small$\lPO$} (i22);

        \draw[po] (init) edge (i11);
        \draw[po] (init) edge node[left] {\small$\lPO$} (i21);

        \draw[rf] (init) edge[bend right] node[above] {\small$\lRF$} (i11);
        \draw[rf] (init) edge[bend left]  node[above] {\small$\lRF$} (i21);

      \end{tikzpicture}
    \end{minipage}
    \hfill
    \begin{minipage}[c][1\width]{0.3\textwidth}
      \begin{tikzpicture}[yscale=1,xscale=1.3]

        \node (init) at (1,  1.5) {$\Init$};

        \node (i11) at ( 0,  0) {$\rlab{}{x}{0}$};
        \node (i12) at ( 0, -2) {$\wlab{}{y}{1}$};

        \node (i21) at ( 2,  0) {$\rlab{}{y}{1}$};
        \node (i22) at ( 2, -2) {$\wlab{}{x}{1}$};

        \draw[po] (i11) edge node[left] {\small$\lPO$} (i12);
        \draw[po] (i21) edge node[right] {\small$\lPO$} (i22);

        \draw[po] (init) edge node[right] {\small$\lPO$} (i11);
        \draw[po] (init) edge node[right] {\small$\lPO$} (i21);

        \draw[rf] (init) edge[bend right] node[above] {\small$\lRF$} (i11);
        \draw[rf] (i12)  edge             node[below] {\small$\lRF$} (i21);

      \end{tikzpicture}
    \end{minipage}
    \hfill
    \begin{minipage}[c][1\width]{0.3\textwidth}
      \begin{tikzpicture}[yscale=1,xscale=1.3]

        \node (init) at (1,  1.5) {$\Init$};

        \node (i11) at ( 0,  0) {$\rlab{}{x}{1}$};
        \node (i12) at ( 0, -2) {$\wlab{}{y}{1}$};

        \node (i21) at ( 2,  0) {$\rlab{}{y}{0}$};
        \node (i22) at ( 2, -2) {$\wlab{}{x}{1}$};

        \draw[po] (i11) edge node[left] {\small$\lPO$} (i12);
        \draw[po] (i21) edge node[right] {\small$\lPO$} (i22);

        \draw[po] (init) edge node[left] {\small$\lPO$} (i11);
        \draw[po] (init) edge node[left] {\small$\lPO$} (i21);

        \draw[rf] (i22)  edge             node[below] {\small$\lRF$} (i11);
        \draw[rf] (init) edge[bend left ] node[above] {\small$\lRF$} (i21);

      \end{tikzpicture}
    \end{minipage}
    \begin{minipage}[c][1\width]{0.3\textwidth}
      \begin{tikzpicture}
        \node (init) at (1,  1.5) {$\Init$};

        \node (i11) at ( 0,  0) {$\rlab{}{x}{1}$};
        \node (i12) at ( 0, -2) {$\wlab{}{y}{1}$};

        \node (i21) at ( 2,  0) {$\rlab{}{y}{1}$};
        \node (i22) at ( 2, -2) {$\wlab{}{x}{1}$};

        \draw[po, red] (i11) edge node[left] {\small$\lPO$} (i12);
        \draw[po, red] (i21) edge node[right] {\small$\lPO$} (i22);

        \draw[po] (init) edge node[left] {\small$\lPO$} (i11);
        \draw[po] (init) edge node[left] {\small$\lPO$} (i21);

        \draw[rf, red] (i22)  edge             node[below] {\small$\lRF$} (i11);
        \draw[rf, red] (i12)  edge             node[below] {\small$\lRF$} (i21);
      \end{tikzpicture}
    \end{minipage}
  \end{figure}

  Теперь, абстрагируясь от кода программы, мы можем анализировать полученные из отношений
  графы. Например, так как последнее поведение нельзя воспроизвести поочередным исполнением команд из
  разных потоков, то мы можем захотеть запретить его.
  Это легко сделать, потребовав иррефлексивность транзитивного замыкания
  объединения отношений: $ (\textit{po} \cup \textit{rf})^+ $.
  Хотя в более сложных случаях этого ограничения не достаточно \cite{rc11}.

  Такой анализ обычно преследует следующие цели:
  \begin{itemize}
    \item сформулировать ограничения на исполнения программы:
    например, модель памяти RC11 запрещает поведения, в которых отношение <<произошло до>> содержит
    циклы, которое в свою очередь состоит из комбинации более примитивных отношений \cite{rc11};
    \item доказать вложенность одной модели в другую:
    например, компиляция нашего языка под архитектуру POWER корректна, если после нее в модели
    архитектуры \cite{axiomatic_memory_model_for_power_mp} не появилось новых поведений относительно
    модели памяти языка;
    \item оценить свойства исполнения или модели в целом:
    например, монотонность модели, которая говорит о том, что если части исполнения программы
    допустимы, то и все исполнение допустимо.
  \end{itemize}

  Анализу также сопутствуют формальные доказательства всех утверждений и свойств, например, в системе Coq.
  И так как базовый формализм аксиоматических моделей памяти основан на бинарных отношениях, нам часто
  приходится доказывать свойства бинарных отношений, их равенства или неравенства, которые не
  специфичны для моделей памяти (универсальны) и могут быть автоматизированы.

  Поэтому цель данной работы состоит в том, чтобы упростить доказательства в моделях памяти путем
  автоматизации доказательств свойств бинарных отношений.

  \section{Анализ Алгебры Клини и ее расширения}

    Сначала рассмотрим, как можно представить бинарные отношения в виде алгебры с предикатами равенства
    ($ = $) и неравенства ($ \leq $) и определим свойство универсальности (общезначимости) этих
    соотношений.

    Далее определим формальную алгебру Клини, относительно которой бинарные отношения полны и корректны как модель.
    Это позволит с помощью проверки выводимости в алгебре Клини проверять равенства и неравенства бинарных отношений.

    Затем рассмотрим различные расширения алгебры Клини и проанализируем их полезность в контексте
    моделей памяти.
    В конце раздела можно найти краткие итоги этого анализа в виде Таблицы \ref{tab:compare_algebras}.

    \subsection{Алгебра отношений}
      Для некоторого множества $ O $, зададим \textit{бинарные отношения}
      $ a, b \subseteq \mathcal{P}(O \times O) $
      и операции над ними:
      \begin{enumerate}
        \item композиция:
         $$a \cdot b \triangleq \{ (x, y) : \exists z : (x, z) \in a, (z, y) \in b \} $$
        с нейтральным элементом (множеством всех петель) $ 1 \triangleq \{(x, x) : x \in O\} $
        и нулем (пустым отношением) $ 0 \triangleq \emptyset $;
        \item рефлексивное транзитивное замыкание:
        $$ a^* \triangleq \bigcup\limits_{n \in \overline{0..n}} a^n
        \text{, где}\;\;
        a^n \triangleq \begin{cases}
          a^{n-1} \cdot a & n \ge 1\\
          1          & n = 0
        \end{cases}
        $$
       \item объединение:
       $$ a \cup b = \{(x, y) : (x, y) \in a ~\text{или}~ (x, y) \in b \} $$

      \end{enumerate}
      Также будем пользоваться нотацией для транзитивного замыкания: $ x^+ \triangleq x \cdot x^*$.

      \textit{Алгеброй отношений} $\mathit{Rel}\langle O \rangle$
      назовем кортеж  $\langle O, \cup, \cdot, \_^* , 0, 1\rangle $.

      Для любых двух выражений $ f, e \in \mathit{Rel}\langle O \rangle$ определим выражение \textit{равенства} и
      \textit{неравенства}, как теоретико-множественные операции равенства и включения множеств
      соответственно:

      $$ f = e \triangleq f \subseteq e \wedge e \subseteq f \;\;\;\;\;\;\;\;\;\;\;\;\; f \leq e \triangleq f \subseteq e $$

      Обозначим за $\mathit{Rel}$ - класс алгебр $ \mathit{Rel}\langle O \rangle $ для всех $ O $.

      Для определения общезначимости оценки выражения введем еще несколько обозначений:
      \begin{itemize}
        \item конечный алфавит $ \Sigma $;
        \item выражения $ f, e $ состоящие из конечного количества связок
        ($ \cup, \cdot, \_^* , 0, 1 $) и атомарных переменных из алфавита $ \Sigma $;
        \item элементарная функция оценки S, которая сопоставляет атомарным переменным произвольные
          бинарные отношения из алгебры $ Rel \langle O \rangle $.
      \end{itemize}
      Тогда (не)равенство выражений $ f $ и $ g $ является \textit{общезначимым в классе алгебр отношений}
      ($\mathit{Rel} \models f \leq g, \mathit{Rel} \models f = g $),
      если после оценки переменных любой функцией $ S $ для любой алгебры $ \mathit{Rel}\langle O \rangle $
      получается верное (не)равенство бинарных отношений.

      Неформально говоря, общезначимое соотношение является универсальным свойством
      бинарных отношений, не зависящим от значений переменных. Например: $ r \cup (r \cdot r) \leq r^*$
      
    \subsection{Алгебра Клини}
      Назовем \textit{Алгеброй Клини} кортеж $\langle A,\cup,\cdot,\_^*,0,1\rangle$ такой, что $\langle A, \cup, \cdot, 0, 1 \rangle$ -
      идемпотентное полукольцо над множеством $A$, а операция $ \_^* $ удовлетворяет ряду аксиом \cite{ka_axioms}:
      \begin{enumerate}
        \item $ 1 \cup a \cdot a^* \leq a^* $;
        \item $ 1 \cup a^* \cdot a \leq a^* $;
        \item $ b \cup a \cdot x \leq x \Rightarrow a^* \cdot b \leq x $;
        \item $ b \cup x \cdot a \leq x \Rightarrow b \cdot a^* \leq x $;
      \end{enumerate}
      где  $ a \leq b \triangleq a \cup b = b$.

      Тогда за \textit{KA} обозначим аксиоматизированную теорию над алгеброй Клини, состоящую из аксиом
      идемпотентного полу-кольца и аксиом (а-г).

      Записью $ \mathit{KA} \vdash f = g $ будем обозначать факт, что равенство $ f = g $, является
      логическим следствием аксиом \textit{KA}.
      Аналогично определим $ \mathit{KA} \vdash f \leq g $.

      Известно, что теория алгебры Клини разрешима и является PSpace-полной \cite{word_problem_pspace}.
      Также \textit{KA} полна и корректна относительно алгебры отношений \cite{AlgebrasOfRelation}: 
      $ \mathit{Rel} \models f = g $ $ \Leftrightarrow \mathit{KA} \vdash f = g$.

      Поэтому если мы формализуем в Coq процедуру разрешения \textit{KA}-(не)равенств, мы сможем
      автоматически доказывать общезначимые факты для бинарных отношений, которые удовлетворяют
      сигнатуре \textit{Rel}.
      Существующие реализации будут рассмотрены ниже.

      Уже такой небольшой набор операций позволит нам сформулировать с помощью (не)равенств
      \textit{KA}-выражений, например, условие рефлексивности отношения $ r $:
      $$ r \cup 1 \leq r $$
      Пояснение: рефлексивное отношение содержит в себе все петли, то есть $ 1 $, поэтому при
      объединении не изменится.

      Также это позволит автоматически доказывать сложные неравенства, необходимость в которых иногда
      возникает на практике:

      $$ (r_1 \cup r_2)^+ \leq r_1^+ \cup (r_2^+ \cdot r_1^*) \cup (r_2^* \cdot (r_1^+ \cdot r_2^+)^+ \cdot r_1^*) $$

    \subsection{Алгебра Клини с тестами}
      Теперь рассмотрим очень полезное расширение KA: алгебра Клини с тестами.

      \textit{алгебра Клини с тестами}, это кортеж $\langle K,\mathbb{B}, [\cdot] \rangle$ такой, что:

      \begin{itemize}
        \item $K$ - алгебра Клини $\langle A, \cup, \cdot, \_^*, 0, 1 \rangle $;
        \item $\mathbb{B}$ - булева алгебра $\langle B, \wedge, \vee, \neg, \top, \bot \rangle $ (тесты);
        \item $[\:\_\:]$ - гомоморфизм из
          $\langle B, \vee, \wedge, \top, \bot \rangle$
        в $\langle A, \cup,  \cdot, 1, 0 \rangle$.
      \end{itemize}
      Аналогично за $ \mathit{KAT} $ обозначим аксиоматическую теорию, состоящую из аксиом \textit{KA},
      аксиом булевой алгебры $ \mathbb{B}$ и свойств гомоморфизма.
      И аналогично обозначим за $ KAT \vdash f = g, f \leq g $ выводимость в этой теории.

      Также расширим определение бинарных отношений $Rel \langle O \rangle $, добавив булеву алгебру $\langle
      \mathcal{P}\langle O \rangle, \cap, \cup, O, \emptyset \rangle$ и гомоморфизм $ [a] \triangleq \{(x, x): x \in a\} $.
      То есть тесты в модели бинарных отношений - это множества элементов из $O$, которые можно
      воспринимать как логические элементы. А гомоморфизм $[\:\_\:]$ сопоставляет им множество петель.
      Последовательная композиция отношений с тестами позволяет фильтровать их по истинностным значениям
      этих тестов.

      Такая расширенная алгебра отношений полна и корректна относительно алгебры Клини с тестами
      \cite{kat_completeness}: $\mathit{KAT} \vdash f = g \Leftrightarrow \mathit{Rel} \models f = g$.
      
      Задача проверки выводимости (не)равенств в \textit{KAT} разрешима и является PSpace-полной
      \cite{kat_complexity}. Также существует формализация алгоритма разрешения в Coq \cite{kat},
      которая будет рассмотрена в следующих разделах.

      В моделях памяти доменами отношений являются элементарные события, потому данная теория позволяет
      нам накладывать любые вычислимые предикаты на события в программе. Например, мы можем определить
      множество операций чтения/записи как W/R соответственно.
      Это позволяет нам, сказать, что отношение <<прочитано из>> (rf) задано только между
      операциями чтения и записи \cite{rc11}:
      $$ \text{rf} \leq [W] \cdot \text{rf} \cdot [R] $$
      Пояснение: $ [W] $ - это множество петель над событиями записи, а $[R]$ - над операциями чтения.
      Если ребра отношения \textit{rf} существуют только между ними, то после фильтрации отношение не
      уменьшится. 

%     Это дает нам возможность выразить переход между фиксированными командами $ a $ и $ b $:
%    $ [\lambda x, x = a]\cdot 1 \cdot[\lambda x, x =b] $. Или например факт того, что если какое-то утверждение $ d $
%    верно в домене, то будет верно и на кодомене отношения можно выразить так: $ [!d] \cdot r \cdot [d] \leq 0 $

    \subsection{Алгебры Клини с инверсией}
      Теперь добавим к алгебре Клини операцию инверсии $ \_^{\smile} $, удовлетворяющую следующим аксиомам:
      \begin{enumerate}
        \item $ (a \cup b)^{\smile} = a^{\smile} \cup b^{\smile} $;
        \item $ (a \cdot b)^{\smile} = b^{\smile} \cdot a^{\smile} $;
        \item $ (a^*)^{\smile} = (a^{\smile})^* $;
        \item $ {a^{\smile}}^{\smile} = a $;
        \item $ a \leq a \cdot a^{\smile} \cdot a $.
      \end{enumerate}
      Тогда мы получим теорию \textit{алгебр Клини с инверсией} (\textit{KAC}).
      В ней аналогично с \textit{KA} определяются (не)равенства, оценки и выводимость.

      В алгебре отношений операции инверсии соответствует операция переворачивания всех ребер:
      $$ a^\smile \triangleq \{ (y, x): (x, y) \in a \} $$

      \textit{KAC} корректна и полна относительно бинарных отношений с операцией инверсии, но не
      корректна относительно регулярных языков, в частности, аксиома (д) в них не выполнена. Теорию без
      этой аксиомы обычно обозначают как \textit{KAC}$^-$ \cite{AlgebrasOfRelation}.

      Для \textit{KAC} задача разрешимости остается PSpace-полной, но, в сравнении с \textit{KAC}$^-$,
      алгоритмы разрешения пока что сложны для формализации в Coq \cite{AlgebrasOfRelation}, поэтому
      полных реализаций пока нет.

      В моделях памяти иногда возникают функциональные отношения, для которых верно, что каждому
      элементу слева отношение сопоставляет не более одного справа.
      Свойство, что отношение $ r $ является функциональным, можно выразить в
      \textit{KAC} с помощью операции инверсии ($ \_^{\smile} $):
      $$ r^{\smile} \cdot r \leq 1 $$
      Пояснение: если отношение функциональное, то любой переход по ребру от <<значения>> к
      <<аргументу>> и по любому другому ребру опять к <<значению>> приведет нас в тоже значение. То
      есть композиция таких переходов - это всегда петля.

    \subsection{Решетки Клини}
      Теперь рассмотрим одно из самых значительных расширений алгебр Клини.
      Если мы добавим к \textit{KA} операцию пересечения($\cap$),
      то получим \textit{решетку Клини} (\textit{KL}).

      Алгебра отношение \textit{Rel} в этом случае дополняется следующей операцией:

      $$ f \cap e \triangleq \{ (x, y) \colon (x, y) \in f \wedge (x, y) \in e \} $$

      Данная аксиоматическая теория является разрешимой \cite{petri_for_kal}, но алгоритм разрешения чрезвычайно
      сложен и требует экспоненциального количества памяти, поэтому автоматизация (не)равенств из этой
      теории в Coq пока не представляется возможной. Также существует доказательство того, что
      эта задача является EXPSpace-полной задач \cite{complexity_of_regular_intersection}.
      
      Тем не менее операция пересечения была бы очень полезна в моделях памяти.
      Часто ограничение на исполнение программы формулируется как ацикличность отношения <<произошло
      до>>, которое в свою очередь является комбинацией других базовых отношений \cite{rc11}. С помощью
      новой операции ацикличность легко выразить неравенством:
      $$ r^+ \cap 1 \leq 0 $$
      Пояснение: любой цикл при транзитивном замыкании приводит к появлению петель и наоборот.

    % NOTE: Зоопарк рано закрывался и мы не все успели посмотреть:
    %       GKAT, NetKAT,  Pointer KA, Concurrent KA, Nominal KA, KA with relation, Mutable tests

    \subsection{Аллегории Клини}
      Если же мы одновременно добавим в алгебру Клини операции пересечения $\cap$ и инверсии ($\_^{\smile}$),
      то получим богатую теорию \textit{аллегорий Клини (KAl)}.

      Недавние результаты показывают, что для такой теории существует система аксиом, которая полна и
      корректна, но пока только относительно регулярных языков \cite{axioms_kal}. Она также разрешима
      и EXPSpace-полная \cite{dec_kal}.

      Кроме создания системы аксиом для бинарных отношений, остается также открытым вопрос о добавлении
      в теорию универсального отношения ($\top \triangleq O \times O $) \cite{axioms_kal}. Это позволило бы, например,
      выразить тотальность отношения $r$, то есть факт того, что между любой парой событий есть ребро
      хотя бы в одну сторону: $\top \leq r \cup r^\smile$.
      % TODO (нужно ресечить): поддерживает ли эта аксиоматизация тесты?

    % NOTE: В этой таблице нету KAC^- потому, что про нельзя сказать, что она поддерживает какие-либо
    %       операции для бинарных отношений. 
    \begin{table}[!h]
      \caption{Сравнение расширений алгебр Клини}
      \label{tab:compare_algebras}
      \centering
      \begin{tabularx}{\textwidth}{|>{\hsize=0.7\hsize}Y|
        >{\hsize=1.3\hsize}Y|Y|Y|}\hline
        Название & Пример доказываемого свойства бинарных отношений & Сложность & Реализация в Coq
        \\\hline
        \textit{KA} & Рефлексивность, Транзитивность & PSpace & relation-algebra, atbr
        \\\hline
        \textit{KAT} & Предикаты на доменах & PSpace & relation-algebra
        \\\hline
        \textit{KAC} & Функциональные отношения & PSpace & ---
        \\\hline
        \textit{KL}  & Ацикличность, Разность & EXPSpace & ---
        \\\hline
        \textit{KAl}$_{Lang}$ & --- & EXPSpace & ---
        \\\hline
      \end{tabularx}
    \end{table}

  \section{Анализ существующих реализаций в Coq}\label{section:coq_impls}
    % NOTE - Что требуется для достижения цели
    %      - Что уже сделано
    %      - Почему сделанного недостаточно

    Теперь рассмотрим существующие реализации алгебры Клини и ее расширений в Coq: библиотеки
    atbr \cite{atbr} и relation-algebra \cite{kat}.
    Остановимся на каждой подробно и опишем их минусы и плюсы.
    % NOTE: Есть еще реализация \cite{moreira}, которая вроде по-другому формализует решалку и работает
    % иногда на порядок быстрее atbr. Но я не нашел к у них исходников. Видимо их нет в публичном доступе

    \subsection{atbr}

      Эта библиотека предоставляет инструменты для автоматического доказательства общезначимых
      (не)равенств в \textit{KA} и \textit{KAC}$^-$.

      То есть в случае, когда выражение содержит операцию инверсии $\_^\smile$, у нас нет гарантии, что
      общезначимое (не)равенство будет доказано автоматически. Алгоритм разрешения для \textit{KAC}$^-$
      значительно проще, чем для \textit{KAC} и сводится лишь к проталкиванию операции инверсии до
      атомарных переменных, что вряд ли может быть полезно для бинарных отношений.
      
      \textit{KA} реализована в полной мере с доказательством теоремы о полноте, что позволяет быть
      уверенным в корректности кода библиотеки.

    \subsection{relation-algebra}

      Эта библиотека является развитием atbr, в которой допущена ошибка при дизайне, и поэтому
      авторам перед расширением функционала пришлось переписать ее с нуля. В ней реализована полная
      поддержка \textit{KAT} и \textit{KA}.

      % TODO FIXME: уточнить текст: cpc не сводится в равенствам Хоара
      Также важно отметить, что relation-algebra реализует алгоритм исключения гипотез
      \cite{hkat, hkat_cpc}, что позволяет автоматически доказывать
      не только общезначимые, но и те (не)равенства которые следуют из гипотез определенного вида, а
      конкретнее, сводящиеся к равенствам Хоара ($ r = 0 $).

      Это чрезвычайно полезно на практике.
      Например, мы можем доказывать монотонность некоторых свойств отношений,
      то есть факт того, что если для нескольких отношений свойство выполняется, то и для их
      комбинации оно тоже будет выполнено.
      К примеру монотонность пустоты отношений:
      $$ r_1 \leq 0, r_2 \leq 0 \vdash r_1 \cup r_2 \leq 0 \;\;\;\;\;\;\;\;\;\;\;\;\; r \leq 0 \vdash r^+ \leq 0 $$

      В своем интерфейсе библиотека использует канонические структуры и классы типов
      \cite{canonical_structures} в качестве средств полиморфизма. Это позволяет ей обобщить алгоритм
      разрешения (не)равенств для любой структуры, которая отвечает сигнатуре и аксиомам \textit{KAT}.
      
      Чтобы генерация доказательств работала для конкретно заданной структуры необходимо предъявить
      операции, соответствующие сигнатуре \textit{KAT} и доказать, что для них выполнены все аксиомы.

\finishrelatedwork

  \section{Постановка задачи}
    % NOTE Текст здесь должен следовать из цели (см. введение)
    % NOTE Следующая глава должна ссылкать на эти задачи и показывать, почему они решены

    % TODO Возможно формулировка того, где мы применяем KAT надо обобщить ?

    Для того, чтобы исследовать применение теории алгебры Клини на практике, была взята библиотека hahn \cite{hahn}.
    Она содержит базовую формализацию модели исполнения и доказательства огромного числа лемм, которые
    непосредственно используются для построения различных моделей памяти \cite{imm}.

    Так как цель этой работы заключается в исследовании применимости теории Клини к моделям памяти,
    то задачи этой работы следующие:
    \begin{itemize}
      \item применить библиотеку relation-algebra, которая реализует автоматическое разрешение
        \textit{KAT}-(не)равенств, к доказательствам в hahn с целью упростить их;
      \item оценить объем доказательств, которые получилось упростить; проанализировать
        перспективность нового метода.
    \end{itemize}

  \chapterconclusion
    Расширения теории алгебр Клини могут сильно облегчить разработку и исследование аксиоматических моделей памяти,
    так как через них можно выразить многие важные в этой области свойства. К сожалению, немногие
    расширения возможно реализовать в Coq эффективно и даже те, что реализованы, потребовали огромного труда разработчиков.

    Но возможно, что даже существующие разработки в этой области помогут существенно упростить
    работу с моделями памяти. 

\chapter{Применение \textit{KAT} к моделям памяти}\label{chapter:2}
 % NOTE Needs:
 %      Предполагаемое теоретическое решение
 %      Обоснование, почему оно удовлетворяет требованиям, сформулированным в первой главе
 %      Теоретическое сравнение с существующими решениями

  Теперь опишем предлагаемый способ применения библиотеки для автоматического разрешения (не)равенств
  бинарных отношений с тестами relation-algebra для упрощения доказательств в библиотеке hahn.

  Далее сравним новый подход к автоматизации доказательств с теми, которые уже применяются в hahn для автоматизации доказательств.

  \section{Описание решения проблемы}

    В Coq доказательства состоят из последовательности команд (\textit{тактик}), каждая из
    которых упрощает или полностью доказывает текущее утверждение.

    Библиотека relation-algebra предоставляет тактики \coqe{kat} и \coqe{hkat},
    которые позволяют автоматически доказать общезначимые или следующие из специальных гипотез
    (не)равенства соответственно.

    Как упоминалось в первой главе, для их использования необходимо определить сигнатуру \textit{KAT} для
    используемой в hahn реализации бинарных отношений и доказать выполнимость аксиом.

    Чтобы автоматически доказать с помощью новых тактик какое-то утверждение необходимо, чтобы оно было
    сформулировано как проверка общезначимости \textit{KAT}-(не)равенств (или как проверка следствия из
    гипотез, с которыми способна работать \coqe{hkat}).
    Поэтому также необходимо переформулировать некоторые утверждения.

    \subsection{Определение экземпляра \textit{KAT}}

      В библиотеке hahn уже определены многие базовые операции с бинарными отношениями, такие как
      объединение ($r_1 \cup r_2$) или композиция ($r_1 \cdot r_2$). Поэтому предлагается
      лишь объявить экземпляр канонической структуры \coqe{kat.ops}, которую предоставляет
      relation-algebra. Он сопоставит сигнатуру \textit{KAT} с уже определенными в hahn операциями.
      Также этот экземпляр будет содержать булеву алгебру доменов отношений, которую для этого
      требуется определить и доказать необходимые аксиомы.

      Далее интерфейс библиотеки relation-algebra требует определить экземпляр класса типов
      \coqe{kat.laws}, содержащий доказательства выполнения всех аксиом \textit{KAT} для операций из hahn.
      Все они были доказаны с помощью встроенных в Coq тактик, а также частично были переиспользованы
      леммы из relation-algebra и тактики из hahn.

      После этого механизмы вывода типов в Coq могут восстановить информацию о том, что выражение
      принадлежит \textit{KAT}-сигнатуре, если оно состоит из соответствующих операций.
      Поэтому тактики \coqe{kat(hkat)} смогут автоматически сгенерировать доказательства для
      утверждений, если те являются
      общезначимыми (или следуют из специальных гипотез).

    \subsection{Переформулирование определений}

      Некоторые леммы в hahn сформулированы в терминах не принадлежащих сигнатуре \textit{KAT}, но тем не менее
      могут быть в ней переформулированы.

      Для примера рассмотрим утверждение \coqe{max_elt a r}.
      Оно означает, что \coqe{a} является максимальным событием в отношении \coqe{r}, то есть из \coqe{a} нет исходящих
      ребер отношения. В hahn оно определяется так:

      \begin{lstlisting}[gobble=8]
        Definition max_elt {A: Type} (r: relation A) (a: A) :=
          forall (b: A), not (r a b).
      \end{lstlisting}

      Оно не отвечает сигнатуре алгебры Клини с тестами, и его нельзя доказать автоматически.
      Но его можно переформулировать как $ [eq\ a] \cdot r \le \emptyset $, где $eq\ a$ - предикат проверяющих событие на равенство
      с $a$.
      То есть $ a $ - максимальный элемент тогда и только тогда, когда множество путей, которые сначала
      проходят по петле в элементах равным $a$, а потом по отношению r, пусто
      (иначе из $a$ есть исходящие ребро).

      Чтобы формально обосновать предположение о том, что оба этих определения эквиваленты, докажем лемму:
      \begin{lstlisting}[gobble=8]
        Lemma max_elt_iff_kat:
          forall (a: A) (r: relation A), max_elt r a <-> [eq a] \cdot r \leq \emptyset.
      \end{lstlisting}
        % Proof.
        %   unfold_all; unfold max_elt; firstorder.
        %   - eapply H. rewrite H2, H0. apply H1.
        %   - eapply H. esplits; eauto.
        % Qed.

      Также, используя эту лемму, с помощью последовательного применения встроенной тактики
      \coqe{rewrite} мы можем в процессе доказательства заменять старые определения на новые: 

      \begin{lstlisting}[gobble=8]
        Lemma max_elt_iter: max_elt r a -> max_elt r^+ a.
        Proof.
          repeat rewrite -> max_elt_iff_kat.
          (* current goal: [eq b] \cdot r \leq \emptyset -> [eq b] \cdot r^+ \leq \emptyset *)
          hkat.
        Qed.
      \end{lstlisting}

      Если утверждение примет необходимый вид, то \coqe{(h)kat} автоматически докажет его.
      
      Благодаря такому подходу, мы не будем переписывать определения всех теорем и лемм, а только изменим их доказательства.
      Это сохранит их интерфейс и не сломает нетронутых доказательств, которые используют переформулируемые утверждения.

      В этом примере у нас получилось привести исходное определение \coqe{max_elt} к виду $r \leq \emptyset$, что
      дает возможность не только автоматически доказывать такие утверждения, но и использовать
      их в качестве гипотез.
      Благодаря этому, после переписывания всех вхождений \coqe{max_elt} в утверждении леммы
      \coqe{max_elt_iter}, тактика \coqe{hkat} автоматически сгенерировала остальное доказательство.

      Кроме гипотез вида $r \leq \emptyset$ библиотека relation-algebra поддерживает гипотезы нескольких других
      видов \cite{kat}, которые к нему сводятся или могут быть исключены \cite{hkat,hkat_cpc}:
      \begin{itemize}
        \item $ r = 0 $;
        \item $[a] \cdot x = x \cdot [b]$, $[a] \cdot x \leq x \cdot [b]$;
        \item $x \cdot [a] = [b] \cdot x$, $x \cdot [a] \leq [b] \cdot x$;
        \item $ r \leq [a] \cdot r $, $ r \leq r \cdot [a]$;
        \item $ a = b $, $ a \leq b $;
        \item $[a] \cdot r = [a]$, $r \cdot [a] = [a]$, где $r$ - атомарная переменная.
      \end{itemize}

      Исходя из выше описанного, все определения в hahn, которые получилось выразить в сигнатуре
      \textit{KAT} можно разделить на 3 группы:
      \begin{enumerate}
        \item Утверждения, которые можно использовать как гипотезы и доказывать их автоматически.
        \item Утверждения, которые нельзя использовать как гипотезы, но можно их доказывать.
        \item Определения отношений, которые могут входить в совершенно любые утверждения.
      \end{enumerate}

      Те утверждения, которые не получилось переформулировать или которые относятся ко второй группе будут
      просто игнорироваться тактикой \coqe{hkat}. А отношения, определение которых не выражается в
      \textit{KAT} будут восприниматься как атомарные. 
      
      В Таблице \ref{tab:redefine_succ} указаны все переопределения,
      которые удалось выполнить в hahn, разбитые по этим группам.
      Также в Таблице \ref{tab:redefine_fail} можно найти несколько
      важных определений, которые не удалось выразить через \textit{KAT},
      но удалось через другие расширения алгебры Клини.

      % TODO (поправить код): добавить про множества
      \begin{table}[!h]
        \caption{Переформулирование определений в сигнатуру \textit{KAT}}
        \label{tab:redefine_succ}
        \centering
        \begin{tabularx}{\textwidth}
          {|>{\hsize=0.78\hsize}L|>{\hsize=1.11\hsize}Y|>{\hsize=1.11\hsize}Y|}\hline
          Название & Оригинальное определение (в логике первого порядка) & \textit{KAT}
          \\\hline

          \multicolumn{3}{|>{\centering\hsize=3\hsize}X|}
            {Переформулирование утверждений, которые можно использовать в качестве гипотез}
          \\\hline

          \coqe{upward_closed r p} & $ \forall x y. r\ x\ y \implies p\ y \implies p\ x $ & $ r \cdot [p] \leq [p] \cdot r $
          \\\hline

          \coqe{doma r p} & $ \forall x y. r\ x\ y \implies p\ x $ & $ r \leq [p] \cdot r $
          \\\hline
          \coqe{domb r p} & $ \forall x y. r\ x\ y \implies p\ y $ & $ r \leq r \cdot [p] $
          \\\hline

          \coqe{max_elt a r} & $ \forall y. \neg (r\ a\ y)$ & $ [eq\ a] \cdot r \leq 0 $
          \\\hline
          \coqe{min_elt a r} & $ \forall x. \neg (r\ x\ a)$ & $ r \cdot  [eq\ a] \leq 0$
          \\\hline
          \coqe{wmax_elt a r} & $ \forall y. r\ a\ y \implies a = y $ & $ [eq\ a] \cdot r \leq [eq\ a] \cdot r \cdot
          [eq\ a] $
          \\\hline
          \coqe{wmin_elt a r} & $ \forall x. r\ x\ a \implies a = x $ & $ r \cdot [eq\ a] \leq [eq\ a] \cdot r \cdot [eq\ a] $
          \\\hline

          \coqe{DOM a r} & $ \forall x y. r\ x\ y \implies x = a $ & $ r \leq [eq\ a] \cdot r$
          \\\hline
          \coqe{COD a r} & $ \forall x y. r\ x\ y \implies y = a $ & $ r \leq r \cdot [eq\ a]$
          \\\hline

          \multicolumn{3}{|>{\centering\hsize=3\hsize}X|}
            {Переформулированные утверждений, которые нельзя использовать в качестве гипотез}
          \\\hline
          \coqe{transitive r} & $ \forall x y z. r\ x\ z \implies r\ z\ y \implies r\ x\ y $ & $ r \cdot r \leq r $
          \\\hline
          \coqe{reflexive r} & $ \forall x. r\ x\ x $ & $ 1 \leq r $
          \\\hline

          \multicolumn{3}{|c|}{Переформулирование определений отношений}
          \\\hline
          \coqe{restr_rel p r} & $ \forall x y. r\ x\ y \wedge p\ x \wedge p\ y $ & $ [p] \cdot r \cdot [p] $
          \\\hline
          \coqe{clos_refl r} & $ \forall x y. x = y \wedge r\ x\ y $ & $ 1 \sqcup r $
          \\\hline
        \end{tabularx}
        где
        \coqe{(eq a : A -> Prop)} - предикат равенства с \coqe{a},
        \coqe{(r : relation A)} - отношение,
        \coqe{(a, x, y : A)} - события,
        \coqe{(p: A -> Prop)} - предикаты на событиях,
        \coqe{A} - тип доменов отношений, событий
      \end{table}

      \begin{table}[!h]
        \caption{Переформулирование определений, которые не удалось выразить в KAT, но можно выразить в
          других расширениях алгебры Клини}
        \label{tab:redefine_fail}
        \centering
        \begin{tabularx}{\textwidth}
          {|>{\hsize=0.78\hsize}L|>{\hsize=1.11\hsize}Y|>{\hsize=1.11\hsize}Y|}\hline
          Название & Оригинальное определение (в логике первого порядка) & Новое определение
          \\\hline
          % $ minus\_rel\ r_1\ r_2 $ & $ r_1 \setminus r_2 $ & $ r_1 \redmath{\cap}\redmath{\neg} r_2 $
          % \\\hline

          \coqe{irreflexive r} & $ \forall x. \neg (r\ x\ x) $ & $ 1 \redmath{\cap} r \leq 0 $
          \\\hline

          \coqe{acyclic r} & $ irreflexive\ r^+ $ & $ 1 \redmath{\cap} r^+ \leq 0 $
          \\\hline

          \coqe{is_total r} & $\forall x y. r\ x\ y \vee r\ y\ x$ & $\redmath{\top} \leq r \cup r\redmath{^\smile}$
          \\\hline

          \coqe{cross_rel p1 p2} & $ \forall x y.  p_1\ x \wedge p_2\ y $ & $ [p_1] \cdot \redmath{\top} \cdot [p_2] $
          \\\hline

          \coqe{singl_rel a b} & $ \forall x y. x = a \wedge y = b $ & $ [eq\ a] \cdot  \redmath{\top} \cdot [eq\ b] $
          \\\hline

        \end{tabularx}
        Пояснение: \textcolor{red}{красным} выделены не входящие в сигнатуру KAT связки,\\
        где $\top$ - универсальное отношение, \coqe{(p$_1$, p$_2$ : A -> Prop)} - предикаты на событиях
      \end{table}

      Написав предложенные переопределения и доказав соответствующие леммы об их корректности, мы сможем
      автоматически доказывать утверждения, которые удалось выразить с помощью
      алгебры Клини с тестами, если они общезначимы или следуют из утверждений, которые удалось
      переформулировать в специальной форме.

      Важно отметить, что общезначимость означает, что для алгоритма разрешения (не)равенств предикаты
      и атомарные отношения непрозрачны. То есть он не может использовать те свойства, которые следуют
      из их определения.

      Например, лемму \coqe{seq_eq_wmax} на Листинге \ref{lst:fail_eq},
      \coqe{hkat} доказать не сможет, несмотря на то, что она принадлежит сигнатуре \textit{KAT}, так
      как рассматривает \coqe{eq b} как атомарный символ.

      Но зная, что этот предикат \coqe{eq} выражает равенство, мы можем легко доказать
      недостающее свойство (\coqe{[eq b] \cdot r \cdot [eq b] \leq [eq b]})
      и закончить доказательство леммы. К сожалению, это свойство не сводится к равенству Хоара, и его нельзя использовать как гипотезу.
      \begin{lstlisting}[float=!h, gobble=6,
        caption={Пример невозможного использования hkat из-за нехватки гипотезы о внутреннем устройстве
        предиката}, label={lst:fail_eq}]
      Lemma wmax_elt_iff_kat:
        wmax r b <-> [eq b] \cdot r \leq [eq b] \cdot r \cdot [eq b].

      Lemma seq_eq_wmax: wmax r b -> [eq b] \cdot r \leq [eq b].
      Proof.
        rewrite -> wmax_elt_iff_kat.
        (* current goal:
           [eq b] \cdot r \leq [eq b] \cdot r \cdot [eq b] -> [eq b] \cdot r \leq [eq b] *)
        Fail hkat. (* can't solve *)
        assert ([eq b] \cdot r \cdot [eq b] \leq [eq b]) as H.
        { unfold_all; firstorder; congruence. }
        rewrite -> H; trivial
      Qed.
      \end{lstlisting}

      В заключении, чтобы удобно переписывать утверждения состоящие из разных определений, воспользуемся
      тактикой \coqe{autorewrite} \cite{coq_man}, что позволит использовать динамическую базу
      утверждений для переписывания, которую можно пополнять по мере добавления новых определений.
    
      Так же для удобства объявим тактики \coqe{hahn_(h)kat}, которые будут применять \coqe{autorewrite},
      а потом вызывать \coqe{(h)kat}, что также скроет все переформулировки от
      пользователя тактик (см. Листинг \ref{lst:define_lift})

      \begin{lstlisting}[float=!h, gobble=4,
        caption={Переопределение тактик \coqe{h(kat)}, для автоматической замены старых определений на новые}, label={lst:define_lift}]
      Hint Rewrite restr_rel_iff_kat: redefDb.
      Hint Rewrite wmax_elt_iff_kat: redefDb.
      ...
      Ltac lift_to_kat := repeat autorewrite with redefDb in *.
      Ltac hahn_kat  := lift_to_kat; kat.
      Ltac hahn_hkat := lift_to_kat; hkat.
      \end{lstlisting}

  \section{Сравнение с существующими решениями}

    На данный момент в hahn большинство доказательств состоит из ручного использования других, уже
    доказанных утверждений, их автоматического перебора и стандартных тактик Coq.

    Проблема ручного использования очевидна. И по крайней мере от части такого труда \coqe{(h)kat}
    может помочь избавится.

    Автоматический же перебор тоже хорошо справляется с этой задачей, но он предназначен в первую
    очередь для простых утверждений. Проблема этого подхода заключается в том, что не всегда можно по
    утверждению понять <<простое>> ли оно. Иногда перебор занимает значительное
    время и приходится параметризовать его глубиной перебора и вручную стараться выбирать
    минимальное возможное ее значение. Это делает использование этого подхода не удобным.

    Главным преимуществом использования автоматических средств доказательств утверждений из некоторой
    разрешимой теории заключается в том, что существует четкий критерий, когда метод работает, а когда
    нет: если утверждение имеет сигнатуру этой теории и оно общезначимо в ней. Это не только делает его
    более удобным, но дает возможность формально доказывать полноту алгоритма генерации доказательств.

    Кроме предложенного метода к таким средствам относятся, например, встроенная тактика \coqe{tauto}
    \cite{coq_man} для интуиционистского исчисления высказываний.

    Это помогает не только при выборе того или иного метода доказательства, но также дает целую область
    знаний о базовом формализме, на которую мы можем опереться в своих рассуждениях. Например, зная, что
    легко можно доказать любое свойство бинарных отношении с тестами, разработчик может выписать через
    (не)равенство необходимое преобразование текущего утверждения, доказать его одной тактикой
    \coqe{(h)kat} и выполнить преобразование:

    \begin{lstlisting}[float=false, gobble=4,
      caption={Пример доказательства вспомогательного утверждения, необходимого для преобразования, с
        помощью \textit{KAT}}, label={lst:arewrite}]
    Proof.
    ...
    (* current goal: irreflexive (dd^* \cdot (dd^* \cdot de \cdot ee^* \cdot ed)^+) *)
    assert (dd^* \cdot (dd^* \cdot de \cdot ee^* \cdot ed)^+ \leq (dd^* \cdot de \cdot ee^* \cdot ed)^+) as H.
    { kat. }
    rewrite -> H.
    (* current goal: irreflexive ((dd^* \cdot de \cdot ee^* \cdot ed) ^+) *)
    ...
    Qed.
    \end{lstlisting}

    Все же автоматический перебор покрывает большее число простых случаев, потому что слабо ограничен сигнатурой.
    А например, даже самое простое утверждение, которое содержит пересечение отношений, \coqe{(h)kat}
    решить не в силах. Но по мере усложнения утверждений количество бесполезных действий, совершаемых
    перебором, резко увеличивается, чего не происходит с более специализированными методами.
    
    Поэтому эти два подхода не исключают друг друга, а дополняют.

  \chapterconclusion
    Применение \textit{KAT} для автоматизации доказательств - это не универсальный, но удобный
    инструмент, который служит дополнением к уже имеющимся, что может сделать  разработку моделей
    памяти проще и быстрее.
    % TODO FIXME: может еще че написать.

\chapter{Анализ результатов применения \textit{KAT} к моделям памяти}\label{chapter:3}
  % NOTE: описание, как результаты, полученные во второй главе реализуются на практике
  %       описание сложностей, с которыми столкнулись при реализации

  Теперь, когда мы получили возможность использовать новый метод автогенерации доказательств, проанализируем его
  применение к леммам в библиотеке hahn.

  Сначала в этой главе будут рассмотрены проблемы, с которыми пришлось столкнуться при этом, а также
  будет описано как удалось полностью или частично их решить.

  После этого подробно будет описано, как с помощью нового метода изменились доказательства в hahn.

  \section{Проблемы в использовании \coqe{(h)kat}}
    После реализации всех экземпляров классов типов и канонических структур оказалось, что Coq все еще
    не может восстановить информацию о том, что некоторые операции принадлежат сигнатуре \textit{KAT}.

    Так же оказалось, что тактика \coqe{hkat} тратит очень много времени на анализ гипотез, которые она
    может использовать для генерации доказательства.
    \subsection{Проблемы с выводом типов}
      Изначально библиотека была спроектирована с использованием наиболее общих интерфейсов. Поэтому
      сигнатура моноида, которую включает в себя \textit{KAT}, сформулирована с учетом
      поддержки гетерогенных структур.
      Применительно к бинарным отношениями это значит, что типы левых и правых концов могут
      отличаться.

      В hahn бинарные отношения гомогенные, то есть соединяются элементы одного и того же
      типа: типа событий в программе. Поэтому типы левых и правых концов, которыми
      параметризован моноид, не
      используются при определении экземпляра сигнатуры. В результате чего, механизм унификации Coq не
      может вывести эти типы, и тактики \coqe{kat} и \coqe{hkat} не работают.

      Решением этой проблемы стало явное указание типов-параметров моноида. Для этого определение
      оргинальных тактик \coqe{hkat/kat} было скопированно в \coqe{hahn_kat} и \coqe{hahn_hkat}
      было скопировано и явно прописаны типы параметров. Заметим, что
      скопирована была не вся реализация этих тактик, а лишь верхний уровень, который вызывал
      алгоритм непосредственно разрешения (не)равенств. Этого оказалось достаточно.

    \subsection{Скорость агрегации гипотез}

      Тактика \coqe{hkat} включает в себя алгоритм исключения гипотез \cite{hkat,hkat_cpc}, который
      сводит задачу доказательства из гипотез к доказательству общезначимого утверждения,
      и потом фактически применяет тактику \coqe{kat}. Этот алгоритм должен сначала агрегировать
      гипотезы, то есть привести их к одной гипотезе вида
      $r \leq 0$ и именно этот процесс занимает наибольшее время работы \coqe{hkat}, иногда больше минуты.

      Дело в том, что агрегация работает путем перебора всех гипотез текущего доказательства и
      последовательных попыток
      применения всех лемм агрегации, которые разбивают равенства на два неравенства,
      объединяют неравенства вида $r \leq 0$ и приводят гипотезы из специального вида к $r \leq 0$.

      Главным образом проблема производительности была решена тем, что все переформулирования были
      изменены так, чтобы новые определения сразу имели предагрегированный вид ($r \leq 0$).

      Также было обнаружено, что перебор в агрегации был не эффективным, так как часто пытался
      трансформировать гипотезы, которые уже были приведены к виду $r \le 0$, что всегда оканчивалось
      неудачей. Поэтому разделением его на фазы удалось ускорить \coqe{hahn_hkat} в среднем на 100
      миллисекунд на леммах из hahn. 

  \section{Описание результатов}

  % TODO: добавить примеры когда доказать не получилось, например про wmax или про листы
  
    Некоторые доказательства в hahn получилось полностью автоматизировать, а некоторые значительно
    упростить. Рассмотрим отдельно каждую из этих групп доказательств, и в конце приведем полную
    статистику.

    \subsection{Примеры полностью доказанных утверждений}

      Леммы, которые получилось полностью доказать с помощью новых тактик особенно интересны
      потому, что в них может пропасть необходимость. Некоторые утверждения выносятся как отдельные
      леммы, только чтобы не перегружать текущее доказательство, в чем отпадает необходимость, если они
      доказываются с помощью одной тактики.

      Для примера рассмотрим фрагмент доказательства одного из свойств ацикличности, фундаментального
      понятия в контексте моделей памяти:

      \begin{lstlisting}[float=!h, gobble=8]
        Lemma acyclic_union: acyclic r -> acyclic (r' \cdot r^*) ->
          acyclic (r \cup r').
        Proof.
          unfold acyclic; ins.
          (* current goal: irreflexive (r \cup r')^+ *)
          rewrite path_union.
          (* current goal: irreflexive (r^+ \cup (r^* \cdot r')^+ \cdot r^+) *)
        ...
        Qed.

        Lemma path_union (r r': relation A) :
          (r \cup r')^+ \leq r^+ \cup (r^* \cdot r')^+ \cdot r^+.
        Proof.
          apply inclusion_t_ind_right.
          unionL; [vauto|].
          by rewrite rtE; rewrite <- !ct_step; basic_solver 12.
          relsf; unionL.
          - by unionR left; rewrite ct_unit.
          - by rewrite !seqA; rewrite <- ct_end; basic_solver 12.
          - rewrite (ct_step (r^+ \cdot r')).
          rewrite <- inclusion_t_rt at 1; basic_solver 22.
          - rewrite !seqA, inclusion_t_rt at 1.
          rewrite <- (ct_end (r^* \cdot r')); basic_solver 12.
        Qed.
      \end{lstlisting}

      Лемму \coqe{acyclic_union} мы не можем полностью автоматизировать, так как ацикличность требует операции
      пересечения отношений ($\cap$), но ее доказательство использует в качестве преобразования
      неравнество \coqe{path_union}, которое новый метод может доказать автоматически.

      Раньше лемма \coqe{path_union} требовала десяток нетривиалных строчек доказательства, где в
      нескольких местах использовались тактики с разной глубиной перебора \coqe{basic_solver N}.

      Теперь мы можем доказать эту вспомогательную лемму одной тактикой или вообще не выносить ее и
      сгенерировать доказательство <<на месте>>:

      \begin{lstlisting}[float=!h, gobble=8]
        Lemma acyclic_union: acyclic r -> acyclic (r' \cdot r^*) ->
          acyclic (r \cup r').
        Proof.
          unfold acyclic; ins.
          assert(path_union:(r \cup r')^+ \leq r^+ \cup (r^* \cdot r')^+ \cdot r^+) by hahn_kat.
          rewrite path_union.
        ...
        Qed.
      \end{lstlisting}

      В некоторых подобных случаях тактики \coqe{hahn_(h)kat} заменили собой доказательства, занимающие
      до 70 строк.
      
      Кроме преобразований бинарных отношений с тестами полностью автоматизировались монотонность
      свойств, которые тактика \coqe{hkat} может использовать как гипотезы
      (см. Таблицу \ref{tab:redefine_succ}).

      Например монотонность свойства элемента быть максимальным в отношении (в комментариях приведено
      старое доказательство):
      \begin{lstlisting}[float=false, gobble=8]
        Lemma max_elt_t : max_elt r a -> max_elt (r^+) a.
        Proof. hahn_hkat. Qed.
        (* Proof.
             red; ins; apply clos_trans_t1n in REL; induction REL; eauto.
           Qed. *)
      \end{lstlisting}

    \subsection{Примеры частичного применения \coqe{(h)kat}}
      Некоторые из тех доказательств, которые не удалось автоматизировать полностью, получилось
      значительно упростить.

      Во многих случаях когда полной автоматизации мешает всего одна <<сложная>> гипотеза,
      после ее использования оставшаяся часть доказательства решается автоматически.
      % В некоторых случаях это позволяло избавиться от 15 строк доказательства из 35.

      Также тактиками \coqe{hahn_(h)kat} получилось заменить в некоторых местах тактики основанные переборе.
      Это имеет смысл, потому что при написании новых доказательств разработчик, смотря на текущее
      утверждение, скорее всего будет использовать инструменты, которые гарантированно его доказывают.

      \begin{lstlisting}[float=false, gobble=8, label={lst:auto_replace},
        caption={Пример замены тактики основанной на переборе на \coqe{kat} (в комментариях указано
          старое доказательство)}]
        Lemma seq_ct_absorb_r: r^+ \cdot r' \subseteq r' \cup r^* \cdot ((r \cdot r') \ r').
        Proof.
          rewrite <- seq_rt_absorb_r; hahn_kat.
          (* rewrite <- seq_rt_absorb_r; eauto with hahn. *)
        Qed.
      \end{lstlisting}

      В предыдущем разделе уже было сказано, что упростилась работа с общезначимыми преобразованиями
      отношений. Благодаря этому удалось частично упростить леммы, в которых доказательство этих
      преобразований не было вынесено.

      Также в нескольких леммах было достаточно добавить в контекст уже доказанное утверждение, чтобы
      \coqe{hkat} смогла использовать его как гипотезу и автоматически сгенерировать доказательство:

      \begin{lstlisting}[float=false, gobble=8,
        caption={Пример автоматизации с использованием уже доказанной гипотезы (в комментариях указано
          старое доказательство)}]
        Lemma seq_eqv_max: [max_elt r] \cdot r \leq 0.
        Proof. basic_solver. Qed.

        Lemma seq_eqv_max_t: [max_elt r] \cdot r^+ = 0.
        Proof.
          pose (@seq_eqv_max r); hahn_hkat.
          (* rewrite ct_begin; seq_rewrite seq_eqv_max; basic_solver. *)
        Qed.
      \end{lstlisting}  
    
    \subsection{Общая статистика}

      Всего hahn содержит 973 леммы. И часть из них связана не только с отношениями, но и, например, со
      списками. Поэтому при подсчете
      статистики учитывались только те модули, которые содержат свойства бинарных отношений или
      предикатов на их домены. Они суммарно содержат 671 лемму и 1489 строк доказательств.
    
      С помощью нового метода упростились 229 лемм и удалось автоматизировать около 500 строчек
      доказательств.
      При этом 187 лемм не изменили свой размер. В них 3-4 тактики или одна,
      основанная на переборе, заменились на одну тактику \coqe{hahn_(h)kat}, что никак не повлияло на
      размер доказательств в строчках, но упростило их.
      
      Чистая же разница составила 261 строку доказательств.
      Более подробную статистику по каждой тактике можно посмотреть в Таблице \ref{tab:stats_tac}.

      \begin{table}[!h]
        \caption{Статистика применения \textit{KAT} в библиотеке hahn, разбитая по тактикам}\label{tab:stats_tac}
        \centering
        \begin{tabularx}{\textwidth}{|*{18}{>{\centering\arraybackslash}X|}}\hline
          Тактика &
          Полностью доказанные леммы &
          Частично доказанные леммы &
          Количество сокращенных срок доказательств
          \\\hline

          \coqe{hahn_kat} & 103 & 18 & 111
          \\\hline
          \coqe{hahn_hkat} & 84 & 22 & 150
          \\\hline
          Всего & 187 & 40 & 261
          \\\hline
        \end{tabularx}
      \end{table}

      Статистику по сокращению и автоматизации доказательств в зависимости от определений, которые они
      содержатся в леммах, можно увидеть в Таблице \ref{tab:stats_redef}.
      По ней видно, что далеко не все леммы, содержащие утверждение \coqe{wmax(min)_elt}, могут быть
      автоматизированы, что связано с непрозрачностью предиката \coqe{eq}.
      Большое количество лемм использует в качестве предпосылки транзитивность или рефлексивность
      отношений, которые невозможно выразить в виде равенств Хоара ($r \leq 0$) или исключить. 
      Проблема остальных лемм заключается в том, что они
      или гипотезы, из которых они следуют, не укладываются в сигнатуру \textit{KAT}.
      
      \begin{table}[!h]
        \caption{Статистика применения \textit{KAT} в библиотеке hahn, разбитая по определениям}
        \label{tab:stats_redef}
        \begin{tabularx}{\textwidth}
          {|>{\hsize=1.3\hsize}L|>{\hsize=0.9\hsize}Y|>{\hsize=0.9\hsize}Y|>{\hsize=0.9\hsize}Y|Y|Y|}\hline
          Группа определений содержащиеся в леммах$^{*}$ &
          Полностью доказанные леммы &
          Частично доказанные леммы &
          Не упрощенные леммы &
          Сокращено / Автоматизировано & Количество строк до упрощения 
          \\\hline
          \textit{KAT}-(не)равенства & 74 & 5$^{**}$ & 0 & 211/312 & 339 
          \\\hline
          \coqe{max(min)_elt} & 36 & 16 & 19 & 0/54 & 68
          \\\hline
          \coqe{doma(b)} & 36 & 14 & 23 & 44/96 & 254
          \\\hline
          \coqe{wmax(min)_elt} & 14 & 0 & 36 & 0/14 & 52
          \\\hline
          \coqe{restr_rel} & 12 & 0 & 21 & 0/12 & 168
          \\\hline
          \coqe{COD/DOM} & 8 & 0 & 6 & 2/10 & 17
          \\\hline
          \coqe{reflexive} / \coqe{transitive} & 4 & 10 & 87 & 4/31 & 453
          \\\hline
          \coqe{acyclic} & 0 & 5 & 33 & 27/32 & 433
          \\\hline
          \coqe{irreflexive} & 0 & 4 & 28 & 4/8 & 267
          \\\hline
          Всего & 187 & 40 & 250 & 261/491 & 1489
          \\\hline
        \end{tabularx}
        \raggedright
        $^{**}$ - группы, кроме первой, могут пересекаться
      
        $^*$ - в этой группе также находятся утверждения со <<сложными>> гипотезами.
      \end{table}

      Оценим также размер добавленного служебного кода:
      объявление экземпляров сигнатуры \textit{KAT}, доказательство аксиом, переопределение тактик
      \coqe{(h)kat}, а также леммы об эквивалентности старых и новый определений.
      Все это занимает около 350 строк кода, из которых половина - это код спецификаций:
      объявление тактик, объявление сигнатур утверждений, импортирование модулей и т. д. Более
      подробные цифры можно найти в Таблице \ref{tab:util_code}.

      \begin{table}[!h]
        \caption{Статистика по добавленному в hahn коду}\label{tab:util_code}
        \centering
        \begin{tabularx}{\textwidth}
          {|>{\hsize=1.6\hsize}L|>{\hsize=0.8\hsize}Y|>{\hsize=0.8\hsize}Y|>{\hsize=0.8\hsize}Y|}\hline
          & Количество строк спецификаций
          & Количество строк доказательств
          & Количество строк комментариев
          \\\hline

          Объявление экземпляра сигнатуры \textit{KAT} & 65 & 41 & 4
          \\\hline
          Переформулирование определений & 65 & 93 & 7
          \\\hline
          Переопределение тактик \coqe{(h)kat} & 50 & 1 & 8
          \\\hline
          Всего & 180 & 135 & 19
          \\\hline
        \end{tabularx}
      \end{table}

      Если сопоставить количество сокращенных строк и количество добавленных, то можно заметить, что
      кодовая база библиотеки hahn почти не изменилась и даже немного выросла.
      Но стоит отметить, что объем доказательств строго уменьшился, а служебный код в основном состоит
      из небольших лемм об эквивалентности.

      Этот служебный код легко расширять.
      При добавлении новых лемм в hahn вообще не нужно ничего менять, а при
      добавлении нового определения, необходимо будет лишь добавить новую лемму об
      эквивалентности или сразу сформулировать его в сигнатуре \textit{KAT}.
      
  \chapterconclusion

    Из описанных выше результатов видно, что разрешение общезначимых \textit{KAT}-(не)равенств
    способно автоматизировать треть доказательств в библиотеке hahn, связанных с бинарными отношениями.
    А также удалось сократить размеры этих доказательств на 17 процентов.

    При этом новый подход имеет четкие границы применения и не потребует в дальнейшем больших затрат на
    его поддержку, что делает его практичным.

    Из этого можно сделать вывод, что теория алгебр Клини действительно способна ощутимо упростить
    разработку и исследования моделей памяти.
  
%% Макрос для заключения. Совместим со старым стилевиком.
\startconclusionpage

  В данной работе были проанализированы различные расширения алгебры Клини и их реализации в Coq
  с целью исследования их применимости к автоматизации доказательств, связанных с моделями памяти.

  Была выбрана реализация алгебры Клини с тестами (relation-algebra \cite{kat}) как самая полная из
  существующих сегодня, и применена к
  библиотеке hahn, которая является базовым фундаментом для построение аксиоматических моделей памяти,
  с целью выяснить, как много доказательств возможно с ее помощью упростить.

  Был предложен и реализован метод автоматизации доказательств утверждений, которые изначально не
  были сформулированы в сигнатуре \textit{KAT}, но могут быть в ней переформулированы.
  Частично были преодолены проблемы с производительностью нового подхода.

  Результаты показывают, что новый подход позволяет сократить существенное количество доказательств,
  что свидетельствует о перспективности применения теории Алгебр Клини для упрощения разработки и
  исследования моделей памяти.

  При этом большую часть доказательств упростить не удалось из-за невозможности выразить их
  утверждения с помощью сигнатуры \textit{KAT}.
  Но непрекращающиеся исследования оставляют надежду на то, что в скором времени найдутся более простые и
  практичные в формализации доказательства разрешимости других расширений алгебры Клини, которые
  позволят реализовать их в Coq и значительно расширить возможности предложенного подхода.

\printmainbibliography

%% После этой команды chapter будет генерировать приложения, нумерованные русскими буквами.
%% \startappendices из старого стилевика будет делать то же самое
\appendix

% \chapter{Пример приложения}\label{sec:app:1}

\end{document}
 