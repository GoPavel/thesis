\documentclass[times
              %,specification
              %,annotation
              ]{itmo-student-thesis}

\usepackage{amssymb}
\usepackage{mathtools}
\usepackage{lstcoq}
\usepackage{graphicx}
\usepackage[unicode=true,implicit=false, colorlinks=red]{hyperref}
\usepackage{tikz}
\usepackage{subfigure}
\lstset
{
  language=Coq,
  numbers=left,
  mathescape=true
}

\input{defs.tex}

%\let\emptyset\varnothing

\addbibresource{thesis.bib}

\begin{document}
\studygroup{M3439}
\title{Применение теории Алгебр Клини и ее расширений для автоматизации доказательств в системе Coq  }
\author{Головин Павел Андреевич}{Головин П. А.}
\supervisor{TODO}{TODO}{проф., д.т.н.}{главный научный сотрудник Университета ИТМО}
\publishyear{2020}
%% Дата выдачи задания. Можно не указывать, тогда надо будет заполнить от руки.
%\startdate{01}{сентября}{2018}
%% Срок сдачи студентом работы. Можно не указывать, тогда надо будет заполнить от руки.
%\finishdate{31}{мая}{2019}
%% Дата защиты. Можно не указывать, тогда надо будет заполнить от руки.
%\defencedate{15}{июня}{2019}

%\addconsultant{Белашенков Н.Р.}{канд. физ.-мат. наук, без звания}
%\addconsultant{Беззубик В.В.}{без степени, без звания}

\secretary{Павлова О.Н.}

%% Задание
%%% Техническое задание и исходные данные к работе
\technicalspec{TODO}

%%% Содержание выпускной квалификационной работы (перечень подлежащих разработке вопросов)
\plannedcontents{TODO}

%%% Исходные материалы и пособия
\plannedsources{\begin{enumerate}
    \item TODO
\end{enumerate}}

%%% Цель исследования
\researchaim{TODO}

%%% Задачи, решаемые в ВКР
\researchtargets{\begin{enumerate}
    \item TODO
\end{enumerate}}

%%% Использование современных пакетов компьютерных программ и технологий
%\addadvancedsoftware{Пакет \texttt{tabularx} для чуть более продвинутых таблиц}{\ref{sec:tables}, Приложения~\ref{sec:app:1}, \ref{sec:app:2}}
%\addadvancedsoftware{Пакет \texttt{biblatex} и программное средство \texttt{biber}}{Список использованных источников}

%%% Краткая характеристика полученных результатов
\researchsummary{TODO}

%%% Гранты, полученные при выполнении работы
\researchfunding{TODO}

%%% Наличие публикаций и выступлений на конференциях по теме выпускной работы
\researchpublications{TODO
%  \begin{refsection}
%    Однако покажу, как можно ссылаться на свои публикации из списка литературы:
%    \nocite{example-english, example-russian}
%    \printannobibliography
%  \end{refsection}
}

%% Эта команда генерирует титульный лист и аннотацию.
\maketitle{Бакалавр}

%% Оглавление
\tableofcontents

%% Макрос для введения. Совместим со старым стилевиком.
\startprefacepage

%:Needs:
%      Актуальность работы
%      Цели и задачи работы
%      Новизна работы
%      Практическое значение работы
%      Ссылки на доклады и публикации
%      Краткое описание структуры работы по главам

% ASK Можно ли делать ссылки в введении?

  Сегодня компьютерные технологии все чаще используются в медицине, энергетике, финансах и
  машиностроении, где цена ошибки в коде очень высока и даже может стоить человеческих жизней.
  Это заставляет обратить пристальное внимание на корректность программ.

  За последние годы был достигнут большой прогресс в области построения систем интерактивного
  доказательства теорем, которые позволяют формально верифицировать программы.
  Пользователь такой системы должен сначала формализовать программу и ее спецификацию, а потом с помощью
  специального языка написать доказательство, которое система проверит на корректность.
  Примерами таких систем являются Coq\cite{intro_to_coq}, Agda, Isabelle/HOL, Idris.

  Coq - это один из таких инструментов, который имеет наиболее развитую экосистему и большое сообщество.
  Он часто используется для создания верифицированных систем, связанных с компиляцией языков
  программирования\cite{comp-cert, vellvm} и, в частности, для формализации слабых моделей
  памяти\cite{rc11, imm}.

  Модель памяти языка программирования призвана специфицировать поведения параллельных программ в
  присутствии гонок по данным.
  Простые модели памяти позволяют себе просто запрещать гонки или гарантируют последовательную
  согласованность всех операций (событий) в программе.

  Но такой подход сильно ограничивает параллелизм и мешает компилятору оптимизировать код, от чего сильно
  страдает производительность программ.
  Поэтому на сегодняшний день все языки используют более слабые ограничения (слабые модели памяти).

  Такие модели используют бинарные отношения на элементарных событиях чтения и записи, например,
  отношение синхронизации на атомарных переменных <<synchronized with>>(link?), чтобы выделить только
  конфликтующие операции и наложить ограничения на возможные исполнения программы.

  Проблема заключается в том, что создание формальной слабой модели памяти, которая корректно применима
  при компиляции программы под разные архитектуры - очень сложная задача, требующая объемных
  доказательств с аккуратным рассмотрением большого количества случаев.
  Поэтому при разработке современных моделей памяти стараются использовать системы интерактивного
  доказательства теорем\cite{rc11}, чтобы упростить написание и проверку доказательств с помощью
  компьютера.

  Так как, работая со слабыми моделям памяти, мы часто имеем дело с бинарными отношениями, то можно
  попробовать обобщить и вынести (автоматизировать) доказательства утверждений, связанных с их свойствами.
  Это должно облегчить разработку и исследование слабых моделей памяти в системе Coq.

  Алгебра Клини - это алгебраическое обобщение бинарных отношений, регулярных выражений и некоторых
  других конструкций со схожей сигнатурой.
  Эта теория хорошо изучена и имеет ряд интересных расширений.

  Цель данной работы заключается в исследовании перспективности использования теории алгебры Клини и ее
  расширений для упрощения формальных доказательств в системе Coq, связанных с моделями памяти.
  % TODO Упоминать ли модели памяти в введении?
  %      Название работы позволяет писать более общо, но без моделей памяти цели работы может показаться неясной.
  % TODO Посмореть на этот момент еще раз, когда вторая и третья главы будут написаны.

  %% Краткое описание глав

  В первой главе мы рассмотрим алгебру Клини и ее расширения, проанализируем их применимость к
  доказательствам в моделях памяти, сформулируем задачи и цели работы.

  Во второй главе мы опишем способ, которым можно применить формализацию в Coq расширения алгебры Клини к
  доказательства моделей памяти.

  В третьей главе мы проанализируем проблемы, которые возникли при непосредственной автоматизации
  доказательств, и ее опишем результаты.

\chapter{Обзор}
\startrelatedwork
  %% Постановка цели

  Как было сказано выше, модели памяти могут строиться с помощью бинарных отношений над множеством
  атомарных событий. Такие модели называются аксиоматические\cite{axiomatic_memory_model_for_power_mp}.

  В качестве примера рассмотрим \hyperref[fig:pic1]{Рисунок \ref{fig:pic1}} с программой, код которой
  содержит гонку и может иметь несколько вариантов исполнения.

  \begin{figure}[!h]
    \centering
    \begin{equation}
      \inarrII{
        \readInst{}{a}{x}  \\
        \writeInst{}{y}{1} \\
      }{
        \readInst{}{b}{y}  \\
        \writeInst{}{x}{1} \\
      }
    \end{equation}
    \caption{Пример параллельной программы, содержащей гонку}
    \label{fig:pic1}
  \end{figure}

  % На рисунке \ref{fig:pic1} мы видим конкретное исполнение программы, то есть мы знаем, например, какие
  % значения были прочитаны из памяти в каждой строчке.

  Для каждого возможного исполнения
  строятся аксиоматически заданные базовые отношения,
  как например на \hyperref[fig:pic2]{Рисунке \ref{fig:pic2}}, это
  отношение порядка команд в коде программы (\textit{po}), отношение синхронизации между командами над
  атомарными переменными (\textit{sw}) или отношения <<прочитано из>> (\textit{rf}),
  которое показывает где было прочитано записанное значение.

  \begin{figure}[!h]
    \begin{minipage}[c][1\width]{0.3\textwidth}
      \begin{tikzpicture}[yscale=1,xscale=1.3]

        \node (init) at (1,  1.5) {$\Init$};

        \node (i11) at ( 0,  0) {$\rlab{}{x}{0}$};
        \node (i12) at ( 0, -2) {$\wlab{}{y}{1}$};

        \node (i21) at ( 2,  0) {$\rlab{}{y}{0}$};
        \node (i22) at ( 2, -2) {$\wlab{}{x}{1}$};

        \draw[po] (i11) edge node[left] {\small$\lPO$} (i12);
        \draw[po] (i21) edge node[right] {\small$\lPO$} (i22);

        \draw[po] (init) edge (i11);
        \draw[po] (init) edge node[left] {\small$\lPO$} (i21);

        \draw[rf] (init) edge[bend right] node[above] {\small$\lRF$} (i11);
        \draw[rf] (init) edge[bend left]  node[above] {\small$\lRF$} (i21);

      \end{tikzpicture}
    \end{minipage}
    \hfill
    \begin{minipage}[c][1\width]{0.3\textwidth}
      \begin{tikzpicture}[yscale=1,xscale=1.3]

        \node (init) at (1,  1.5) {$\Init$};

        \node (i11) at ( 0,  0) {$\rlab{}{x}{0}$};
        \node (i12) at ( 0, -2) {$\wlab{}{y}{1}$};

        \node (i21) at ( 2,  0) {$\rlab{}{y}{1}$};
        \node (i22) at ( 2, -2) {$\wlab{}{x}{1}$};

        \draw[po] (i11) edge node[left] {\small$\lPO$} (i12);
        \draw[po] (i21) edge node[right] {\small$\lPO$} (i22);

        \draw[po] (init) edge node[right] {\small$\lPO$} (i11);
        \draw[po] (init) edge node[right] {\small$\lPO$} (i21);

        \draw[rf] (init) edge[bend right] node[above] {\small$\lRF$} (i11);
        \draw[sw] (i12)  edge             node[below] {\small$\lSW$} (i21);

      \end{tikzpicture}
    \end{minipage}
    \hfill
    \begin{minipage}[c][1\width]{0.3\textwidth}
      \begin{tikzpicture}[yscale=1,xscale=1.3]

        \node (init) at (1,  1.5) {$\Init$};

        \node (i11) at ( 0,  0) {$\rlab{}{x}{1}$};
        \node (i12) at ( 0, -2) {$\wlab{}{y}{1}$};

        \node (i21) at ( 2,  0) {$\rlab{}{y}{0}$};
        \node (i22) at ( 2, -2) {$\wlab{}{x}{1}$};

        \draw[po] (i11) edge node[left] {\small$\lPO$} (i12);
        \draw[po] (i21) edge node[right] {\small$\lPO$} (i22);

        \draw[po] (init) edge node[left] {\small$\lPO$} (i11);
        \draw[po] (init) edge node[left] {\small$\lPO$} (i21);

        \draw[sw] (i22)  edge             node[below] {\small$\lSW$} (i11);
        \draw[rf] (init) edge[bend left ] node[above] {\small$\lRF$} (i21);

      \end{tikzpicture}
    \end{minipage}
    \caption{Все возможные исполнения код на \hyperref[fig:pic1]{Рисунке \ref{fig:pic1}}}
    \label{fig:pic2}
  \end{figure}

  Мы абстрагируемся от кода программы, анализируя базовые отношения и стоим из них более сложные. Так
  например, одно из ключевых отношений <<произошло до>> может определяется как транзитивное замыкание
  объединения двух других отношений: $ \textit{hb} \triangleq (\textit{sw} \cup \textit{sb})^+ $ \cite{rc11}.

  Этот анализ обычно преследует следующие цели:
  \begin{itemize}
    \item сформулировать ограничения на исполнения программы:
    например, модель памяти RC11 запрещает поведения, в которых отношение <<произошло до>> содержит
    циклы \cite{rc11}.
    \item доказать вложенность одной модели в другую:
    например, компиляция нашего языка под архитектуру POWER корректная, если после нее в модели
    архитектуры\cite{axiomatic_memory_model_for_power_mp} не появилось новых поведений относительно
    модели памяти языка.
    \item оценить свойства исполнения или модели в целом:
    например, монотонность модели, которая говорит о том, что если части исполнения программы
    допустимы, то и все исполнение допустимо.

  \end{itemize}

  Анализу также сопутствуют формальные доказательства всех утверждений и свойств, например, в системе Coq.
  И так как базовый формализм аксиоматических моделей памяти основан на бинарных отношениях, нам часто
  приходится доказывать свойства бинарных отношений, их равенства или неравенства, которые не
  специфичны для моделей памяти (универсальны) и могу быть автоматизированы.

  Поэтому цель данной работы состоит в том, чтобы упростить доказательства в моделях памяти путем
  автоматизации доказательств свойств бинарных отношений.

  \section{Анализ Алгебры Клини и ее расширения}

    Бинарные отношения мы представим как алгебру с предикатами равенства ($ = $) и неравенства ($ \leq $),
    через которые впоследствии будем выражать все остальные их свойства.

    Определим формальную алгебру Клини, относительно которой бинарные отношения полны и корректны как модель.
    Это позволит нам с помощью проверки выводимости в алгебре Клини проверять равенства и неравенства бинарных отношений.

    Затем мы рассмотрим различные расширения алгебры Клини и проанализируем их полезность в контексте моделей памяти.

    \subsection{Алгебра отношений}
      Для некоторого множества $ O $, зададим \textit{бинарные отношения}
      $ a, b \subseteq \mathcal{P}(O \times O) $
      и операции над ними:
      \begin{itemize}
        \item композиция:
         $$a \cdot b \triangleq \{ (x, y) : \exists z : (x, z) \in a, (z, y) \in b \} $$
        с нейтральным элементом $ 1 \triangleq \{(x, x) : x \in O\} $
        и нулем $ 0 \triangleq \emptyset $
        \item рефлексивное транзитивное замыкания:
        $$ a^* \triangleq \bigcup\limits_{n \in \overline{0..n}} a^n $$,
       где
       \begin{equation*}
        a^n \triangleq \begin{cases}
          a^{n-1} \cdot a & n > 1\\
          1          & n = 0
        \end{cases}
       \end{equation*}
       \item объединение:
       $$ a \cup b = \{(x, y) : (x, y) \in a ~\text{или}~ (x, y) \in b   \} $$
       %
      \end{itemize}
      Также будем пользоваться нотацией для транзитивного замыкания: $ x^+ \triangleq x \cdot x^*$.

      \textit{Алгеброй отношений} $\mathit{Rel}\langle O \rangle$
      назовем кортеж  $\langle O, \cup, \cdot, \_^* , 0, 1\rangle $.

      Для любых двух выражений $ f, e \in \mathit{Rel}$ определим выражение \textit{равенства} и
      \textit{неравенства}, как теоретико-множественные операции равенства и включения множеств
      соответственно:

      $$ f = e \triangleq f \subseteq e \wedge e \subseteq f \;\;\;\;\;\;\;\;\;\;\;\;\; f \leq e \triangleq f \subseteq e $$

      Обозначим за $\mathit{Rel}$ - класс алгебр $ \mathit{Rel}\langle O \rangle $ для всех $ O $.

      Для определения общезначимости оценки выражения введем еще несколько обозначений:
      \begin{itemize}
        \item конечный алфавит $ \Sigma $
        \item выражения $ f, e $ состоящие из конечного количества связок
        ($ \cup, \cdot, \_^* , 0, 1 $) и атомарных переменных из алфавита $ \Sigma $.
        \item элементарная функция оценки S, которая сопоставляет атомарным переменным некоторые
          бинарные отношения из алгебры $ R \langle O \rangle $.
      \end{itemize}
      Тогда (не)равенство выражений $ f $ и $ g $ является \textit{общезначимым в классе алгебр отношений}
      ($\mathit{Rel} \models f \leq g, \mathit{Rel} \models f = g $),
      если после оценки переменных любой функцией $ S $ для любой алгебры $ \mathit{Rel}\langle O \rangle $
      получается верное (не)равенство бинарных отношений.

% TODO: Кажется это не очень нужно, потому что переусложняет текст и не сильно влияет на суть.
%    \subsection{Моноид, группа и идемпотентное полу-кольцо}
%      Назовем кортеж $ \langle A, \cdot, 1 \rangle $ \textit{моноидом}, если выполняются следующие правила:
%      $$ x \cdot (y \cdot z) = (x \cdot y) \cdot z \;\;\;\;\;
%         x \cdot 1 = x \;\;\;\;\;
%         1 \cdot x = x
%      $$
%      Также будем говорить, что моноид \textit{коммутативный}, если выполнено:
%      $$ x \cdot y = y \cdot x $$
%      и \textit{идемпотентный} если:
%      $$ x \cdot x = x $$
%
%      Если же в для моноида $ \langle A, \cdot, 1 \rangle $ назад обратная операция $ \_^{-1} $, удовлетворяющая свойствам:
%      $$ x \cdot x^{-1} = 1 \;\;\;\;\;
%         x^{-1} \cdot x = 1
%      $$
%      то назовем кортеж $ \langle A, \cdot, 1, \_^{-1}\rangle $ \textit{группой}
%
%      Определим \textit{идемпотентное полукольцо} как кортеж $ \langle A,+,\cdot,\_^*,0,1 \rangle$, для которого верно, что
%      $ \langle A, \cdot, 1 \rangle $ - моноид,
%      а $ \langle A, +, 0 \rangle $ - коммутативный моноид, и выполнены следующий правила:
%      $$ a \cdot (b + c) = (a \cdot b) + (a \cdot c) \;\;\;\;\;
%         (a + b) \cdot c = (a \cdot c) + (b \cdot c) \;\;\;\;\;
%         0 \cdot a = 0
%      $$

    % TODO: возможно стоит убрать аксиомы
    % TODO: Добавить линки где можно подробнее почитать про все это.
    \subsection{Алгебра Клини}
      % TODO: link на аксиоматизацию
      Назовем \textit{Алгеброй Клини} кортеж $\langle A,+,\cdot,\_^*,0,1\rangle$ такой, что $\langle A, +, \cdot, 0, 1 \rangle$ - идемпотентное полукольцо и операция $ \_^* $ удовлетворяет ряду аксиом:
      \begin{enumerate}
        \item $ 1 + a \cdot a^* \leq a^* $
        \item $ 1 + a^* \cdot a \leq a^* $
        \item $ b + a \cdot x \leq x \Rightarrow a^* \cdot b \leq x $
        \item $ b + x \cdot a \leq x \Rightarrow b \cdot a^* \leq x $
      \end{enumerate}
      где  $ a \leq b \triangleq a + b = b$

      Тогда за \textit{KA} обозначим аксиоматизированную теорию над алгеброй Клини, состоящую аксиом
      идемпотентного полу-кольца и аксиом (а-г).

      Записью $ \mathit{KA} \vdash f = g $ будем обозначать факт, что равенство $ f = g $, является
      логическим следствием аксиом \textit{KA}.
      Аналогично определим $ \mathit{KA} \vdash f \leq g $.

      Известно, что теория алгебры Клини разрешима и является PSpace-полной\cite{word_problem_pspace}.
      Также \textit{KA} полна относительно алгебры отношений
      ($ \mathit{Rel} \models f = g $ $ \Leftrightarrow \mathit{KA} \vdash f = g$) (link?).

      Поэтому если мы формализуем в Coq процедуру разрешения \textit{KA}-(не)равенств, мы можем
      автоматически доказывать общезначимые факты для бинарных отношений, которые удовлетворяют
      сигнатуре \textit{Rel}.
      Существующие реализации будут рассмотрены ниже.

      Уже такой небольшой набор операций позволит нам сформулировать с помощью (не)равенств
      \textit{KA}-выражений, например, условие рефлексивности отношения $ r $:
      $$ r = r \cup 1 $$
      Пояснение: рефлексивное отношение содержит в себе все петли, то есть $ 1 $, поэтому при
      объединении не изменится.

      Или решать сложные неравенства, которые иногда возникают на практике:

      $$ (r_1 \cup r_2)^+ \leq r_1^+ \cup r_2^+ \cdot r_1^* \cup r_2^* \cdot (r_1^+ \cdot r_2^+)^+ \cdot r_1^* $$

    % TODO: Ничего не сказало про \top
    \subsection{Алгебра Клини с тестами}
      % TODO: link на определение
      Теперь рассмотрим очень полезное расширение KA, алгебры Клини с тестами.

      \textit{Клини алгебра с тестами}, это кортеж $\langle K,\mathbb{B}, [\cdot] \rangle$ такой, что:

      \begin{itemize}
        \item $K$ - Клини алгебра $\langle A, +, \cdot, \_^*, 0, 1 \rangle $
        \item $\mathbb{B}$ - булева алгебра $\langle B, \wedge, \vee, \neg, \top, \bot \rangle $
        \item $[\cdot]$ - гомоморфизм из
          $\langle B, \vee, \wedge, \top, \bot \rangle$
        в $\langle A, +,     \cdot, 1,    0 \rangle$
      \end{itemize}
      % TODO надо ли сказать, что такое гомоморфизм?
      % TODO: сказать, что тесты должны быть разрешимы
      Аналогично за $ \mathit{KAT} $ обозначим аксиоматическую теорию, состоящую из аксиом \textit{KA},
      булевой алгебры $ \mathbb{B}$ и свойств гомоморфизма. И аналогично обозначим за $ KAT \vdash f = g, f
      \leq g $ выводимость в этой теории.

      Также расширим определение бинарных отношений $Rel \langle O \rangle $, добавив булеву алгебру $\langle
      \mathcal{P}\langle O \rangle, \cap, \cup, O, \emptyset \rangle$ и гомоморфизм $ [a] \triangleq \{(x, x): x \in a\} $. Такая
      расширенная алгебра отношений полна относительно \textit{KAT}:

      ($\mathit{KAT} \vdash f = g \Leftrightarrow \mathit{Rel} \models f = g$) (link?)

      Задача разрешения (не)равенств в \textit{KAT} разрешима и является PSpace-полной\cite{kozen_kat}.
      Существуют формализации в Coq, они будут рассмотрены в следующих разделах. \cite{kat}

      Элементы булевой алгебры называют обычно называются тестами.
      Гомоморфизм отображает их в множество петель, конкатенация с которыми позволяет "фильтровать"
      отношения по условию принадлежности этому множеству петель.
      То есть мы можем задавать предикаты на домены отношения.

      В моделях памяти доменами отношений являются атомарные события. Например, мы можем определить множество
      операций чтения/записи как W/R соответственно.
      Это позволяет нам, например, сказать, что отношение <<прочитано из>> (rf) задано только между
      операциями чтения и записи\cite{rc11}:
      $$ \text{rf} \leq [W] \cdot \text{rf} \cdot [R] $$
      Пояснение: $ [W] $ - это множество петель над событиями записи, а $[R]$ - над операциями чтения.

%     Это дает нам возможность выразить переход между фиксированными командами $ a $ и $ b $:
%    $ [\lambda x, x = a]\cdot 1 \cdot[\lambda x, x =b] $. Или например факт того, что если какое-то утверждение $ d $
%    верно в домене, то будет верно и на кодомене отношения можно выразить так: $ [!d] \cdot r \cdot [d] \leq 0 $

    \subsection{Алгебры Клини с инверсией}
      Теперь добавим к алгебре Клини операцию инвертирования $ \_^{\smile} $, удовлетворяющую следующим аксиомам:
      \begin{enumerate}
        \item $ (a + b)^{\smile} = a^{\smile} + b^{\smile} $
        \item $ (a \cdot b)^{\smile} = b^{\smile} \cdot a^{\smile} $
        \item $ (a^*)^{\smile} = (a^{\smile})^* $
        \item $ {a^{\smile}}^{\smile} = a $
        \item $ a \leq a \cdot a^{\smile} \cdot a $
      \end{enumerate}
      тогда мы получим теорию, так называемую \textit{Алгебрами Клини с инверсией} (\textit{KAC}).
      В ней аналогично с \textit{KA} определяются (не)равенства, оценки и выводимость.

      В алгебре отношений операции инвертирования соответствует операция переворачивания всех стрелок:
      $$ a^\smile \triangleq \{ (y, x): (x, y) \in a \} $$

      \textit{KAC} разрешима и полна относительно бинарных отношений с операцией инверсии, но не полна
      относительно регулярных языков, в частности, аксиома (д) в них необщезначима(link?).
      Это приводит к тому, что хоть задача разрешимости остается также PSpace-полная, текущее
      доказательство теоремы о полноте слишком сложно для формализации в Coq\cite{AlgebrasOfRelation}.

      В моделях памяти иногда возникают функциональные отношения, то есть те, которые являются
      частичными функциями. Свойство, что отношение $ r $ является функциональным, можно выразить в
      \textit{KAC} с помощью операции инвертирования ($ \_^{\smile} $) как $ r^{\smile} \cdot r \leq 1 $.
      % TODO Возможно лушче поменять пример.


    \subsection{Решетки Клини}
      Теперь рассмотрим пожалуй самое полезное расширение алгебр Клини.
      Если мы добавим к \textit{KA} операцию пересечения($\cap$), то получим \textit{решетку Клини} (\textit{KL}).

      Алгебра отношение \textit{Rel} в этом случае дополняется следующей операцией:

      $$ f \cap e \triangleq \{ (x, y) \colon (x, y) \in f \wedge (x, y) \in e \} $$

      Данная аксиоматическая теория является разрешимой, но задача доказательства (не)равенств лежит в
      классе EXPSpace-полных задач\cite{AlgebrasOfRelation}. Существующий алгоритм использует такие
      сложные структуры как автоматы Петри, что вдвойне препятствует формализации в Coq. На данный
      момент реализации нет.

      Тем не менее операция пересечения очень полезна в моделях памяти.
      Часто ограничение на исполнение программы формулируется как ацикличность отношения <<произошло
      до>>, которое в свою очередь является комбинацией других базовых отношений\cite{rc11}. С помощью
      новой операции ацикличность легко выразить неравенством:
      $$ r^+ \cap 1 \leq 0 $$
      Пояснение: любой цикл при транзитивном замыкании приводит к появлению петлей и наоборот.

  \section{Анализ существующих реализаций в Coq}
    % NOTE - Что требуется для достижения цели
    %      - Что уже сделано
    %      - Почему сделанного недостаточно

    Теперь рассмотрим существующие реализации алгебры Клини и ее расширений в Coq: библиотеки
    atbr\cite{atbr} и relation-algebra\cite{kat}.
    Остановимся на каждой подробно и опишем их минусы и плюсы.
    % TODO: правда ли, что для клини алгебры есть только эти две бибилиотеки в Coq?

    % TODO: нужно сослаться на таблицу в тексте
    \begin{table}[!h]
      \caption{Сравнение расширений алгебр Клини}\label{tab1}
      \centering
      \begin{tabularx}{\textwidth}{|*{18}{>{\centering\arraybackslash}X|}}\hline
        Название & Пример доказываемого свойства & Сложность & Реализация в Coq
        \\\hline
        KA & Рефлексивность, Транзитивность & PSpace & relation-algebra, atbr
        \\\hline
        KAT & Предикаты на доменах & PSpace & relation-algebra
        \\\hline
        KAC & Функциональные отношения & PSpace &
        \\\hline
        KL  & Ацикличность, Разность & EXPSpace &
        \\\hline
      \end{tabularx}
    \end{table}

% TODO: переместить в постановку задач
%   \subsection{Тактики Coq}
%      Доказательства с системе Coq записываются как последовательность команд, которые изменяют текущее целевое утверждение. Такие команды называются \textit{тактики}.
%
%      Тактики могут применять аксиомы, гипотезы, переписывать подвыражения, используя уже доказанные равенства, разбивать доказательство на случаи и даже целиком доказывать текущее утверждение.
%

    \subsection{abtr}

      Эта библиотека предоставляет инструменты для автоматического доказательства общезначимых
      (не)равенств в \textit{KA} и \textit{KAC}.

      К сожалению, \textit{KAC} полна только относительно модели регулярный языков, но не бинарных
      отношений и поэтому не может использоваться для наших целей.

      \textit{KA} реализована в полной мере с доказательством теоремы о полноте, что позволяет быть
      уверенным в корректности кода библиотеки.

      % TODO: написать еще что-нибудь.

    \subsection{relation-algebra}

      Эта библиотека является развитием atbr, в которой допущена ошибка при дизайне, и поэтому
      авторам перед расширением функционала пришлось переписать ее с нуля. В ней реализована полная
      поддержка \textit{KAT} и \textit{KA}.

      Главной особенностью relation-algebra является то, что она позволяет автоматически доказывать
      не только общезначимые, но и те (не)равенства которые следуют из гипотез определенного вида, а
      конкретнее, сводящиеся к равенствам Хоара ($ r = 0 $).
      % TODO: <<равенства>> Хоара - это какой-то не очень устоявщийся термин

      % TODO: Возможно стоит помнять пример, так как можно подумать, что kat поддерживает пересечения
      Это чрезвычайно полезно на практике.
      Например, мы можем доказывать монотонность некоторых свойств отношений,
      то есть если факт того, что если для двух отношений свойство выполняется, то и для их комбинации
      оно тоже будет выполнено.
      К примеру монотонность рассмотренной ранее ацикличность можно записать так:
      $$ r_1^+ \cap 1 \leq 0, r_2^+ \cap 1 \leq 0 \vdash (r_1 \cdot r_2)^+ \cap 1 \leq 0 $$

      В своем интерфейса библиотека использует канонические структуры и классы типов, которые являются
      аналогами абстрактных классов в императивных языках программирования.
      Алгоритм разрешения (не)равенств обобщен с их помощью для любой структуры, которая отвечает
      сигнатуре и аксиомам \textit{KAT}.

      Чтобы генерация доказательств работала для конкретно заданной структуры необходимо предъявить
      операции, соответствующие сигнатуре \textit{KAT} и доказать, что для них выполнены все аксиомы.

\finishrelatedwork

  \section{Постановка задачи}
    % NOTE Текст здесь должен следовать из цели (см. введение)
    % NOTE Следующая глава должна ссылкать на эти задачи и показывать, почему они решены

    % TODO Возможно формулировка того, где мы применяем KAT надо обобщить ?

    Для того, чтобы исследовать применение теории алгебры Клини на практике, была взята библиотека hahn\cite{hahn}.
    Она содержит базовую формализацию модели исполнения и доказательства огромного числа лемм, которые
    непосредственно используются для построения различных моделей памяти\cite{imm}.

    % TODO: возможно потом появится еще задачи
    Так как цель этой работы заключается в исследовании применимости теории Клини к моделям памяти,
    то задача этой работы состоит в оценке объема доказательств в hahn, которые возможно упростить с помощью relation-algebra.


  \chapterconclusion
    Расширения алгебры Клини способны сильно облегчить работу с аксиоматическими моделями памяти,
    так как через них можно выразить многие важные в этой области свойства. К сожалению, немногие
    расширения возможно реализовать в Coq эффективно и даже те, что реализованы, потребовали огромного труда разработчиков.

    Тем не менее, возможно уже текущие разработки в этой области могут существенно упростить работу с моделями памяти.

\chapter{Применение \textit{KAT} к моделям памяти}
 % Needs:
 % TODO Предполагаемое теоретическое решение
 % TODO Обоснование, почему оно удовлетворяет требованиям, сформулированным в первой главе
 % TODO Теоретическое сравнение с существующими решениями

  Теперь опишем, как применить библиотеку для автоматического разрешения (не)равенств бинарных
  отношений с тестами relation-algebra для упрощения доказательств в библиотеке hahn.

  Далее сравним новый подход с теми, которые уже применяются в hahn для автоматизации доказательств.

  \section{Описание решения проблемы}

    В Coq доказательства состоят из последовательности команд (\textit{тактик}), каждая из
    которых упрощает или полностью доказывает текущее утверждение.

    Библиотека relation-algebra предоставляет тактики \coqe{kat} и \coqe{hkat},
    которые позволяют автоматически доказать общезначимые или следующие из специальных гипотез
    (не)равенства соответственно.

    Как упоминалось в первой главе, для их использования необходимо определить сигнатуру \textit{KAT} для
    используемой в hahn реализации бинарных отношений и доказать выполнимость аксиом.

    Чтобы автоматически доказать с помощью новых тактик какое-то утверждение необходимо, чтобы оно было
    сформулировано как проверка общезначимости \textit{KAT}-(не)равенств (или следовать из гипотез, с которыми
    способна работать \coqe{hkat}).
    Поэтому также необходимо переформулировать некоторые утверждения.

    \subsection{Определение экземпляра \textit{KAT}}
    % TODO Я не понимаю, стоит ли использовать тут прошлое время. С одной стороны как бы тут итоговое
    % наше решение, а с другой в 3ей главе описывается как это реализуется на практике.

      В библиотеке hahn уже определены многие операции с бинарными отношениями, поэтому было необходимо
      лишь объявить экземпляр канонической структуры \coqe{kat.ops}, который сопоставляет сигнатуру
      \textit{KAT} с уже определенными операциями.
      Также этот экземпляр содержит булеву алгебру доменов отношений, которая была для этого мной
      объявлена.

      Далее интерфейс бибилиотеки relation-algebra требует от нас определить экземпляр класса типа
      \coqe{kat.laws}, содержащий доказательства выполнения всех аксиом \textit{KAT} для наших операций.
      Все они были доказаны с помощью встроенных в Coq тактик, а также частично были переиспользованы
      леммы из relation-algebra.

      После этого механизмы вывода типов в Coq могут восстановить информацию о том, что выражение
      принадлежит \textit{KAT}-сигнатуре, если оно состоит из соответствующих операций.
      Поэтому тактики \coqe{kat(hkat)} смогут автоматически сгенерировать доказательства для
      утверждений, если те являются
      общезначимыми (следуют из специальных гипотез).

      % TODO: выбивается из рассказа и не понятно нужно ли оно вообще здесь
      % Например, в библиотеке уже имеется доказательства того, что встроенный в Coq тип утверждений Prop отвечает
      % аксиомам булевой алгебры, а также лемму о том, что мы можем поточечно расширять алгебраическую структуру.
      % Применив эту лемму к булевой алгебре Prop, мы получим булеву алгебру предикатов $ A \rightarrow Prop $. А применив
      % второй раз, мы получим как раз определения бинарных отношений в hahn $ A \rightarrow A \rightarrow Prop $.

    \subsection{Переформулирование определений}

      Некоторые леммы в hahn сформулированы в терминах не принадлежащих сигнатуре \textit{KAT}, но тем не менее
      могут быть в ней сформулированы.

      Для примера рассмотрим утверждение \coqe{max_elt a r}.
      Оно означает, что \coqe{a} является максимальным событием в отношении \coqe{r}, то есть из \coqe{a} нет исходящих
      стрелок отношения. В hahn оно определяется так:

      \begin{lstlisting}[gobble=8]
        Definition max_elt {A: Type} (r: relation A) (a: A) :=
          forall (b: A) (REL: r a b), False.
      \end{lstlisting}

      Оно не отвечает сигнатуре алгебры Клини с тестами, и его нельзя доказать автоматически.
      Но его можно переформулировать так $ [eq\ a] \cdot r \le \emptyset $, где $eq\ a$ - предикат проверяющих событие на равенство
      c $a$.
      То есть $ a $ - максимальный элемент тогда и только тогда, когда множество переходов, которые сначала
      проходят по петле в элементах равным $a$, а потом по отношению r пусто (из $a$ есть исходящий переход).

      Чтобы формально обосновать предположение о том, что оба этих определения эквиваленты, докажем лемму:
      \begin{lstlisting}[gobble=8]
        Lemma max_elt_iff_kat:
          forall (a: A) (r: relation A), max_elt r a <-> [eq a] \cdot r \leq \emptyset.
      \end{lstlisting}

      Также, используя эту лемму, мы можем с помощью встроеной тактики \coqe{rewrite} заменять старое определение на новое:

      \begin{lstlisting}[gobble=8]
        Lemma max_elt_iter: max_elt r a -> max_elt r^+ a.
        Proof.
          rewrite -> max_elt_iff_kat in *.
          (* current goal: [eq b] \cdot r \leq \emptyset -> [eq b] \cdot r^+ \leq \emptyset *)
          hkat.
        Qed.
      \end{lstlisting}
%        (*red; ins; apply clos_trans_t1n in REL; induction REL; eauto.*)

      Благодаря такому подходу мы не будем переписывать определения всех теорем и лемм, а только изменим их доказательства.
      Это сохранит их интерфейс и не сломает нетронутых доказательств, которые используют переформулируемые утверждения.

      В этом примере у нас получилось привести исходное утверждение к виду $r \leq \emptyset$, поэтому мы можем не только
      автоматически доказывать утверждения вида \coqe{max_elt a r}, но и использовать их в качестве гипотез.
      Благодаря этому в лемме \coqe{max_elt_iter} после переписывания \coqe{max_elt} во всех местах, тактика \coqe{hkat}
      автоматически сгенерировало остальное доказательство.

      Кроме гипотез вида $r \leq \emptyset$ \;\coqe{hkat} поддерживает гипотезы нескольких других видов, которые к нему
      сводятся:
      \begin{itemize}
        \item $ r = 0 $
        \item $[a] \cdot x = x \cdot [b]$, $[a] \cdot x \leq x \cdot [b]$
        \item $x \cdot [a] = [b] \cdot x$, $x \cdot [a] \leq [b] \cdot x$
        \item $ r \leq [a] \cdot r $, $ r \leq r \cdot [a]$
        \item $ a = b $, $ a \leq b $
        \item $[a] \cdot r = [a]$, $r \cdot [a] = [a]$, где $r$ - атомарная переменная
      \end{itemize}

      Исходя из выше описанного, мы можем разделить все определения на 4 группы:
      \begin{itemize}
        \item определения отношений, которые можно выразить в \textit{KAT}
        \item утверждения, которые можно выразить в \textit{KAT} и использовать как гипотезу
        \item утверждения, которые можно выразить в \textit{KAT}, но нельзя использовать как гипотезу
        \item нельзя выразить в \textit{KAT}
      \end{itemize}

      В \hyperref[tab:redefine_succ]{таблице \ref{tab:redefine_succ}} указаны все переопределения,
      которые удалось выполнить в hahn, разбитые по этим группам.
      Также в \hyperref[tab:redefine_fail]{таблице \ref{tab:redefine_fail}} можно найти определения, которые
      удалось выразить не через \textit{KAT}, но через другие расширения алгебры Клини.

      % TODO: про T к этому моменту не было ни слова, вообще то он не входит в KAT.
      \begin{table}[!h]
        \centering
        \begin{tabularx}{\textwidth}{|*{18}{>{\centering\arraybackslash}X|}}\hline
          Название & Оригинальное определение & \textit{KAT}
          \\\hline
          \multicolumn{3}{|c|}{Переформулирование определений отношений}
          \\\hline

          $ restr\_rel\ p\ r $ & $ r\ x\ y \wedge p\ x \wedge p\ y $ & $ [p] \cdot r \cdot [p] $
          \\\hline

          $ clos\_refl\ r $ & $ x = y \wedge r\ x\ y $ & $ 1 \sqcup r $
          \\\hline

          $ cross\_rel\ p_1\ p_2 $ & $ p_1\ x \wedge p_2\ y $ & $ [p_1] \cdot \top \cdot [p_2] $
          \\\hline

          $ singl\_rel\ a\ b $ & $ x = a \wedge y = b $ & $ [eq\ a] \cdot \top \cdot [eq\ b] $
          \\\hline

          \multicolumn{3}{|>{\centering\hsize=3\hsize}X|}
            {Переформулирование утверждений, которые можно использовать в качестве гипотез}
          \\\hline

          $ upward\_closed\ r\ p $ & $ \forall x y, r\ x\ y \rightarrow p\ y \rightarrow p\ x $ & $ [!p] \cdot r \cdot [p] \leq 0 $
          \\\hline

          $ doma\ r\ p $ & $ \forall x y, r\ x\ y \rightarrow p\ x $ & $ [!p] \cdot r \leq 0 $
          \\\hline

          $ domb\ r\ p $ & $ \forall x y, r\ x\ y \rightarrow p\ y $ & $ r \cdot [!p] \leq 0 $
          \\\hline

          $ max\_elt\ a\ r $ & $ \forall b, r\ a\ b \rightarrow \bot $ & $ [eq\ a] \cdot r \leq 0 $
          \\\hline

          $ wmax\_elt\ a\ r $ & $ \forall b, r\ a\ b \rightarrow a = b $ & $ [eq\ a] \cdot r \cdot [!(eq\ a)] \leq 0 $
          \\\hline

          $ min\_elt\ a\ r $ & $ \forall b, r\ b\ a \rightarrow \bot $ & $ r \cdot  [eq\ a] \leq 0$
          \\\hline

          $ wmax\_elt\ a\ r $ & $ \forall b, r\ b\ a \rightarrow a = b $ & $ [!(eq\ a)] \cdot r \cdot [eq\ a] \leq 0 $
          \\\hline

          \multicolumn{3}{|>{\centering\hsize=3\hsize}X|}
            {Переформулированные утверждений, которые нельзя использовать в качестве гипотез}
          \\\hline

          $ transitive\ r $ & $ \forall x y z, r\ x\ z \!\rightarrow\! r\ z\ y \!\rightarrow\! r\ x\ y $ & $ r \cdot r \leq r $
          \\\hline

          $ reflexive\ r $ & $ \forall x, r\ x $ & $ 1 \leq r $
          \\\hline


          $dom\ b\ r$ & $ \forall x y, r\ x\ y \rightarrow x = b $ & $ r = [eq\ b] \cdot r$
          \\\hline

          $cod\ b\ r$ & $ \forall x y, r\ x\ y \rightarrow y = b $ & $ r = r \cdot [eq\ b]$
          \\\hline

        \end{tabularx}
        \caption{Переформулирование определений в сигнатуру \textit{KAT}}
        \label{tab:redefine_succ}
        где
        $\top$ - универсальное отношение,
        \coqe{(eq a : A -> Prop)} - предикат равенства с \coqe{a},
        \coqe{(r : relation A)} - отношение,
        \coqe{(a, b : A)} - события,
        \coqe{(p, p$_1$, p$_2$ : A -> Prop)} - предикаты на событиях,
        \coqe{A} - тип доменов отношений, событий
      \end{table}

    \begin{table}[!h]
      \centering
      \begin{tabularx}{\textwidth}{|*{18}{>{\centering\arraybackslash}X|}}\hline
        Название & Оригинальное определение & Новое определение
        \\\hline
        $ minus\_rel\ r_1\ r_2 $ & $ r_1 \setminus r_2 $ & $ r_1 \sqcap !r_2 $
        \\\hline

        $ irreflexive\ r $ & $ \forall x, r\ x\ x \rightarrow \bot $ & $ 1 \sqcap r \leq 0 $
        \\\hline

        $ acyclic\ r $ & $ irreflexive\ r^+ $ & $ 1 \sqcap r^+ \leq 0 $
        \\\hline

        $ immediate\ r $ & $\!\! r\ a\ b \wedge (\forall c, r\ a\ c \!\rightarrow\! r\ c\ a \!\rightarrow\!\! \bot\!) $ & $ r \sqcap 1 $
        \\\hline

        $ is\_total\ r $ & $\forall x y, r\ x\ y \vee r\ y\ x$ & $ r \sqcup r^\smile \leq 1$
        \\\hline
      \end{tabularx}
      \caption{Переформулирование определений, которые не удалось выразить в KAT, но можно выразить в
        других расширениях алгебры Клини}
      \label{tab:redefine_fail}
    \end{table}

    Теперь мы можем автоматически доказывать утверждения, которые удалось выразить с помощью
    алгебры Клини с тестами, если они общезначимы или следуют из утверждений, которые удалось
    переформулировать в специальной форме.

    Чтобы удобно было переписывать утверждения состоящие из разных определений, определим также
    тактику \coqe{lift_to_kat}, которая будет последовательно применять леммы об эквивалености старых и
    новых определений.

    Так же для удобства объявим тактики $ kat' $/$ hkat' $, которые будет применять $ lift\_to\_kat $, а
    потом вызывать $ kat $/ $ hkat $, что также скроет все переформулировки от ее
    пользователя: см \hyperref[lst:define_lift]{Листинг \ref{lst:define_lift}}

    % TODO: fix floating
    \begin{lstlisting}[float=!h, gobble=4,
      caption={Объявление тактик, которые позволят автоматически доказывать утверждения в старых
        определениях}, label={lst:define_lift}]
    Ltac lift_to_kat :=
       repeat rewrite -> restr_rel_iff_kat in *;
       ...
       repeat rewrite -> wmax_elt_iff_kat in *.

    Ltac kat'  := lift_to_kat; kat.
    Ltac hkat' := ligt_to_kat; hkat.
    \end{lstlisting}

  \newpage % TODO
  \section{Сравнение с существующими решениями}

    На данный момент в hahn большиство доказательств состоит из ручного использования других, уже
    доказанных утверждений, и их автоматического перебора.

    Проблема ручного использования очевидна. И по крайней мере от части такого труда \coqe{(h)kat'}
    может помочь избавится.

    Автоматический же перебор тоже хорошо справляется с этой задачей, но его проблема в том, что мы
    далеко не всегда может понять сработает ли перебор или нет. Иногда перебор занимает значительное
    времени и приходится параматризовывать его глубиной перебора и вручную стараться выбирать
    минимальное возможное ее значение. Это делает использование этого подхода не удобным.

    Главное преимущество использования автоматических разрешителей бинарных отношений заключается в
    том, что мы можем сформулировать четкий критерий когда метод работает, а когда нет: если
    интересуемое утверждение имеет сигнатуру \textit{KAT}, то мы точно его докажем. Причем теорема о
    полноте доказанная для \coqe{(h)kat} дает нам на это формальные гарантии.

    Это помогает не только при выборе того или иного метода доказательства, но также дает целую область
    знаний о базовом формализме, на которую мы можем опереться в свох рассуждениях. Например, зная, что
    мы можем легко доказать любое свойство бинарных отношейни с тестами, разработчик может выписать через
    (не)равенство необходимое преобразование текущего утверждения, доказать его одной тактикой
    \coqe{(h)kat} и выболнить преборазование:

    \begin{lstlisting}[float=false, gobble=4,
      caption={Пример доказательства вспомогательного утверждения, необходимого для преобразования, с
        помощью \textit{KAT}}, label={lst:arewrite}]
    Proof.
    ...
    (* current goal: irreflexive (dd^* \cdot (dd^* \cdot de \cdot ee^* \cdot ed)^+) *)
    arewrite(dd^* \cdot (dd^* \cdot de \cdot ee^* \cdot ed)^+ \leq (dd^* \cdot de \cdot ee^* \cdot ed)^+)
    { kat'. }
    (* current goal: irreflexive ((dd^* \cdot de \cdot ee^* \cdot ed) ^+) *)
    ...
    Qed.
    \end{lstlisting}

    При этом большой плюс автоматического перебора в том, то он покрывает большее число простых
    случаев. Так, например, даже самое простое утверждение, содержащее пересечение отношений,
    \coqe{(h)kat} решить не способна.

    Поэтому имеет смысл сочетать эти подходы.

  \chapterconclusion
    Применение \textit{KAT} для автоматизации доказательств - это не универсальный, но удобный
    инструмент, который служит дополнением к уже имеющимся, что может сделать  разработку моделей
    памяти проще и быстрее.
    % TODO: перечитать

\chapter{Результаты}
  % NOTE: описание, как результаты, полученные во второй главе реализуются на практике
  %       описание сложностей, с которыми столкнулись при реализации

  Теперь, когда мы получили возможность использовать новый метод автогенерации доказательств, проанализируем его
  применение к доказательствам в библиотеке hahn.

  Сначала мы рассмотрим проблемы, с которыми пришлось столкнуться при этом, и опишем как удалось полностью или
  частично их решить.

  После этого подробно будет описано как с помощью нового метода изменились доказательства в hahn.

  \section{Проблемы в использовании \coqe{(h)kat}}
    После реализации всех экземпляров классов типов и канонических структур оказалось, что Coq все еще
    не может восстановить информацию о том, что некоторые операции принадлежат сигнатуре \textit{KAT}.

    Так же оказалось, что тактика \coqe{hkat} тратит очень много времени на анализ гипотез, которая она
    может использовать для генерации доказательства.
    \subsection{Проблемы с выводом типов}
      Изначально библиотека была спроектирована с использованием наиболее общих интерфейсов. Поэтому
      сигнатура моноида, которую включает в себя \textit{KAT}, сформулирована с учетом
      поддержки гетерогенных структур.
      Применительно к бинарным отношениями это значит, что типы левых и правых концов могут
      отличаться.

      В hahn бинарные отношения гомогенные, то есть соединяются элементы одного и того же
      типа: типа событий в программе. Поэтому типы левых и правых концов, которыми
      параметризован моноид, не
      используются при определении экземпляра сигнатуры. В результате чего, механизм унификации Coq не
      может вывести эти типы, и тактики \coqe{kat} и \coqe{hkat} не работают.

      Решением этой проблемы стало явное указание типов-параметров моноида. Для этого определение
      тактик \coqe{kat} и \coqe{hkat} было скопировано и явно прописаны типы параметров. Заметим, что
      скопирована была не вся реализация этих тактик, а лишь верхний уровень, который вызывал
      алгоритм непосредственно разрешения (не)равенств. Этого оказалось достаточно.
      %TODO: ссылка сюда из места где мы говорим про определение (h)kat'

    \subsection{Скорость агрегации гипотез}

      Тактика \coqe{hkat} включает в себя алгоритм исключения гипотез\cite{hkat,hkat_cpc}, который
      сводит задачу доказательства из гипотез к доказательству общезначимого утверждения,
      и потом фактически применяет тактику \coqe{kat}. Этот алгоритм должен сначала агрегировать
      гипотезы, то есть привести их к одной гипотезе вида
      $r \leq 0$ и именно этот процесс занимает наибольшее время работы \coqe{hkat}, иногда больше минуты.

      Дело в том, что агрегация работает путем перебора всех текущих гипотез и последовательных попыток
      применения всех лемм агрегации, которые разбивают равенства на два неравенства, объединяют
      неравенства и приводят гипотезы из специального вида к $r \leq 0$.

      Главным образом проблема производительности была решена тем, что \coqe{hkat} была разделена на
      легкую (\coqe{hkat'}) и полную (\coqe{hkat''}) версии.
      В первой были оставлены только быстрые преобразования и объединение гипотез в одну.
      Это позволило ей почти всегда работать очень быстро.

      Чтобы легкая версия работала в большем числе случаев все переформулирования определений
      делались из расчета на то, что она может работать с ними.

      Полная же версия включает все прежние преобразования и используется редко (5\% случаев, см раздел
      статистика, TODO).

      Также было обнаружено, что перебор в агрегации был не эффективным, так как часто пытался
      трансформировать гипотезы, которые уже были приведены к виду $r \le 0$, что всегда оканчивалось
      неудачей. Поэтому разделением его на фазы удалось ускорить полную версию \coqe{hkat} в среднем на
      5-8 секунд на примерах из hahn.

      % TODO: Попробовать удалять все гипотезы перед запуском hkat, см HahnKat.v

  \section{Описание результатов}

    Некоторые доказательства в hahn получилось полностью автоматизировать, а некоторые значительно
    упростить. Рассмотрим отдельно каждую из этих групп доказательств, и в конце приведем полную
    статистику.

    \subsection{Примеры полностью доказанных утверждений}

      Доказательства, которые получилось полностью доказать с помощью новых тактик особенно интересны
      потому, что часто в них пропадает необходимость. Так получается из-за того, что те свойства,
      которые они выражают уже <<содержатся>> в новом инструменте и могут быть полностью заменены им.

      Как и было предсказано в главе два полностью автоматизировались доказательства утверждений
      состоящих из свойств, которые \coqe{hkat} может использовать как гипотезы
      (см. \hyperref[tab:redefine_succ]{Таблицу \ref{tab:redefine_succ}}).

      Например монотонность свойства элемента быть максимальным в отношении:
      \begin{lstlisting}[float=false, gobble=8]
        Lemma max_elt_t : max_elt r a -> max_elt (r^+) a.
        Proof.
          (* red; ins; apply clos_trans_t1n in REL; induction REL; eauto. *)
          hkat'.
        Qed.
      \end{lstlisting}

      % TODO: Не уверен в плавности этого перехода.
      Также сильно упростилась работа с преобразованиями отношений.
      Например, чтобы, исходя из некоторых гипотез, доказать ацикличность объединения
      отношений ($r \cup r'$), она сначала сводится к иррефлексивности транзитивного замыкания
      $(r \cup r')^+$.
      Затем необходимо заменить это отношения на его надмножество $r^+ \cup (r^* \cdot r')^+ \cdot r^+$.
      Факт того, что это действительно надмножество и такое преобразование
      верно, вынесен в отдельную лемму \coqe{path_union} (\hyperref[lst:path_union]{Листинг \ref{lst:path_union}})
      с нетривиальным доказательством, которое использовало перебор с разной глубиной
      (\coqe{basic_solver n}).

      Сейчас доказательство леммы полностью автоматизированно.

      \begin{lstlisting}[float=false, gobble=8, label={lst:path_union},
        caption={Автоматизация сложных преобразований}]
        Lemma path_union (r r': relation A) : (r \cup r')^+ \leq r^+ \cup (r^* \cdot r')^+ \cdot r^+.
        Proof.
          apply inclusion_t_ind_right.
          unionL; [vauto|].
          by rewrite rtE; rewrite <- !ct_step; basic_solver 12.
          relsf; unionL.
          - by unionR left; rewrite ct_unit.
          - by rewrite !seqA; rewrite <- ct_end; basic_solver 12.
          - rewrite (ct_step (r^+ \cdot r')).
          rewrite <- inclusion_t_rt at 1; basic_solver 22.
          - rewrite !seqA, inclusion_t_rt at 1.
          rewrite <- (ct_end (r^* \cdot r')); basic_solver 12.
          (* kat' *)
        Qed.
      \end{lstlisting}

    \subsection{Примеры частичного применения \coqe{(h)kat}}
      Некоторые из тех доказательства, которые не удалось автоматизировать полностью, получилось
      значительно упростить.

      В таких доказательствах часто автоматизации мешает всего одна <<сложная>> гипотеза,
      и после ее использования оставшаяся часть доказательства решается автоматически. В некоторых
      случаях это позволяло сократить до 40 строк доказательства.

      Также иногда плодотворным является эвристический подход к исключению таких гипотез.
      К примеру, утверждение (\coqe{dom r b}) о том, что отношение \coqe{r} всегда начинается в
      событии, равном \coqe{b}, можно выразить в \textit{KAT} (\coqe{r = [eq b] \cdot r}), но нельзя
      использовать как гипотезу.

      Если это единственная гипотеза, которую мы не можем использовать, то мы можем попробовать
      заменить все вхождения \coqe{r} на
      \coqe{[eq b] \cdot r} и применить \coqe{hkat}. Для удобства можно определить тактику \coqe{elim_dom},
      которая делает переопределяет гипотезу и делает замену.

      \begin{lstlisting}[float=false, gobble=8, label={lst:dom}]
        Ltac elim_dom DOM :=
          apply dom_to_kat in DOM;
          rewrite DOM in *;
          clear DOM.

        Lemma seq_min_rt r r' b (MAX: min_elt r b) (DOM: cod b r'):
          r^* \cdot r' = r'.
        Proof.
          elim_dom DOM.
          (* current goal: r^* \cdot [eq b] \cdot r' = [eq b] \cdot r' *)
          hkat'.
        Qed.
      \end{lstlisting}

    \subsection{Общая статистика}

      В общем в hahn с помощью нового метода удалось сократить доказательства на 471 сточку, упростились
      доказательства более 150 теорем/лемм.
      Подробную статистику по каждой тактике можно посмотреть в
      \hyperref[tab:stats]{Таблице \ref{tab:stats}}.

      % При подсчете статистики использовались утилиты git diff и coqwc

      \begin{table}[!h]
        \centering
        \begin{tabularx}{\textwidth}{|*{18}{>{\centering\arraybackslash}X|}}\hline
          Тактика & Полностью доказанные леммы & Частично доказанные леммы & Количество строк кода
          \\\hline

          \coqe{kat} & 0 & 0 & 0
          \\\hline

          \coqe{hkat} & 0 & 0 & 0
          \\\hline

          \coqe{hkat'} & 0 & 0 & 0
          \\\hline

          \coqe{hkat''} & 0 & 0 & 0
          \\\hline

          Всего: & 0 & 0 & 0
          \\\hline
        \end{tabularx}
        \caption{Статистика применения \textit{KAT} в библиотеке hahn}
        \label{tab:stats}
        где \coqe{hkat'} - быстрая версия, \coqe{hkat''} - полная версия, \coqe{hkat} - их сумма.
      \end{table}

  \chapterconclusion % TODO

    Из описанных выше результатов следует что теория алгебры Клини действительно полезна применительно
    к моделями памяти и способна автоматизировать существенное количество доказательств.

%% Макрос для заключения. Совместим со старым стилевиком.
\startconclusionpage

  В данной работе были проанализированы различные расширения алгебры Клини и их реализации в Coq
  с целью исследования их применимости к автоматизации доказательств в моделях памяти.

  Была выбрана реализация алгебры Клини с тестами (relation-algebra) как самая полная из существующих, и применена к
  библиотеке hahn с целью выяснить, как много доказательств возможно с ее помощью упростить.

  Был предложен и реализован метод автоматизации доказательств утверждений, которые изначально не
  были сформулированы в сигнатуре \textit{KAT}, но могут быть в ней переформулированы.
  Частично были преодолены проблемы с производительностью нового подхода.

  Исследования показали, что новый инструмент позволил сократить существенно количество доказательств,
  что свидетельствует о перспективности применения алгебры Клини с тестами к моделям памяти.
  Надеюсь, что в скором времени найдутся более простые и практичные доказательства разрешимости других
  расширений алгебры Клини, которые позволят формализовать их в Coq и обогатить возможности нового
  инструмента.

\printmainbibliography

%% После этой команды chapter будет генерировать приложения, нумерованные русскими буквами.
%% \startappendices из старого стилевика будет делать то же самое
\appendix

\chapter{Пример приложения}\label{sec:app:1}

  \begin{table}[!h]
    \caption{Сравнение расширений алгебр Клини}\label{tab1}
    \centering
    \begin{tabularx}{\textwidth}{|*{18}{>{\centering\arraybackslash}X|}}\hline
      Сигнатура &
      Временная сложность сравнения на равенство &
      Пространств. сложность сравнения на равенство &
      Временная сложность проверки на пустоту &
      Пространств. сложность проверки на пустоту

      \\\hline
      \textit{KA}
      & TODO & PSpace & TODO & TODO
      \\\hline
      \textit{KAT}
      & TODO & PSpace & TODO & TODO
      \\\hline
      \textit{KAC}
      & TODO & PSpace & TODO & TODO
      \\\hline
      $\textit{KL}_{-}$
      & TODO & ExpSpace & TODO & TODO
      \\\hline
      \textit{KL}
      & TODO & ExpSpace & TODO & TODO
      \\\hline
      \textit{KAl}
      & TODO & TODO & TODO & TODO
      \\\hline
    \end{tabularx}
  \end{table}


\end{document}
